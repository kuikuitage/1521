/******************************************************************************/
/******************************************************************************/
#include <stdlib.h>
// system
#include "sys_types.h"
#include "sys_define.h"
//#include "sys_regs_magic.h"
#include "stdio.h"

// os
#include "mtos_task.h"
#include "mtos_sem.h"
#include "mtos_printk.h"
#include "mtos_mem.h"
#include "mtos_msg.h"
#include "mtos_timer.h"
#include "mtos_misc.h"

// util
#include "class_factory.h"
#include "simple_queue.h"
#include "mem_manager.h"
#include "lib_unicode.h"
#include "lib_util.h"
#include "lib_rect.h"

// driver
#include "driver.h"
#include "hal_base.h"
#include "hal_gpio.h"
#include "hal_dma.h"
#include "hal_misc.h"
#include "hal_uart.h"

#include "common.h"
#include "drv_dev.h"
#include "drv_misc.h"
#include "uio.h"
#include "nim.h"
#include "display.h"
#include "vdec.h"
#include "avsync.h"
#include "scart.h"
#include "rf.h"
#include "gpe.h"
#include "logo.h"

#include "mdl.h"
#include "service.h"
#include "dvb_svc.h"
//#include "dmx_cmd.h"
#include "dvb_protocol.h"
#include "mosaic.h"
#include "pat.h"
#include "sdt.h"
#include "pmt.h"

#include "string.h"
#include "testfm_define.h"
#include "testfm_inc.h"
//#include "dmx_cmd.h"
#include "fcrc.h"
#include "dmx.h"

#include "vfs.h"
//#include "apes.h"
//#include "vpes.h"
//#include "ts.h"
#ifdef ORCHID
#include "projOptionsAutoGenerated.h"

#include "convention.h"
#include "sys_error_types.h"
#include "os_abstraction_api.h"
#include "ts_defs.h"
#include "av_control_api.h"
//#include "ts_over_avp.h"
#include "pes.h"
#endif

//#define __LINUX__
#ifdef __LINUX__
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <pthread.h>
#include <sys/time.h>
#include <signal.h>
#include <unistd.h>
#include "testfm_define.h"
#endif

#ifdef __LINUX__
#define DMX_DRVCMD_TASK_PRIORITY   31
#define DMX_TASK_STK_SIZE          (16 * KBYTES)
#else
#define DMX_DRVCMD_TASK_PRIORITY   51
#define DMX_TASK_STK_SIZE          (4 * KBYTES)
#endif



#define FILTER_BUFFER_SIZE              (4 * KBYTES+188)
#define dmx_timeout 20
#define dmx_timeout2 10
#define TEST_TABLE_ID  0x20
#define DMX_MSG_DEPTH 128
#ifdef WARRIORS
#define dmx_rec_buffer_count  1
#define dmx_rec_buffer_unit 188*4
#define dmx_rec_circle_range_unit 188*40
#define FILTER_NUM     96
#ifndef __LINUX__
#define dmx_rec_buffer_address  0xa1400000  //20M
#else
u8* dmx_rec_buffer_address = NULL;
#endif
#else
#ifdef ORCHID
#define FILTER_NUM     28
#else
#ifdef   JAZZ
#define FILTER_NUM     48
#else
#define FILTER_NUM     31
#endif
#endif
#endif
extern void hal_dcache_flush_all();       
#ifdef __LINUX__
extern RET_CODE dmx_get_record_buffer(void * p_dev, u8** buffer);
extern RET_CODE dmx_get_playback_buffer(void * p_dev, u8** buffer);
#endif

typedef struct
{
    u16 pid;
    u8   table_id;
    u8* buf;
    u32 buf_size;
    dmx_chanid_t  dmx_chanid;
    dmx_ch_type_t  dmx_ch_type;
    u32 length;
}dmx_para_list;

typedef struct
{
    u16 pid;
    u8* buf;
    u32 buf_size;
    dmx_chanid_t  dmx_chanid;
    dmx_rec_mode_t  type_mode;
    dmx_rec_path_t    rec_in;
}dmx_rec_para_list;


typedef struct
{
    dmx_slot_setting_t slot_t;
    dmx_filter_setting_t  alloc_param;
    dmx_chanid_t  handle;
    u8                  table_id;
    u32 size;
    u8* p_data;
    u8*     p_buf;
    void (*parser)(u8* buf);
} filter_attr_t;

typedef enum
{
  DMX_DESC_TEST_START,

  DMX_DESC_TEST_STOP,

  DMX_EIT_TEST_START,

  DMX_EIT_TEST_STOP,
  
  DMX_CMD_NONE

} dmx_cmd_evt_t;

#ifdef __LINUX__
void * class_get_handle_by_id(u8 class_id)
{
  //MT_ASSERT(g_fact_item[class_id].p_item_handle != NULL);
 // MT_ASSERT(class_id < CLASS_ID_CNT);

  return  NULL;//g_fact_item[class_id].p_item_handle;
}
#endif

static BOOL dmx_open_flag = FALSE;

static filter_attr_t filters[FILTER_NUM];
//static BOOL nim_cfg_flag = FALSE;

static dmx_para_list  list[] =
{
    //{0x11,0,NULL,18800,0,DMX_CH_TYPE_TSPKT},
    //{0x0,0,NULL,1024*4,0,DMX_CH_TYPE_SECTION},
    {0x12,0x4f,NULL,1024*16,0,DMX_CH_TYPE_SECTION},
    {0x12,0x4e,NULL,1024*16,0,DMX_CH_TYPE_SECTION},
    {0x12,0x50,NULL,1024*16,0,DMX_CH_TYPE_SECTION},
    {0x12,0x51,NULL,1024*16,0,DMX_CH_TYPE_SECTION}
    #if 0
    {0x12,0x52,NULL,40960,0,DMX_CH_TYPE_SECTION},
    {0x12,0x53,NULL,40960,0,DMX_CH_TYPE_SECTION},
    {0x12,0x54,NULL,40960,0,DMX_CH_TYPE_SECTION},
    {0x12,0x55,NULL,40960,0,DMX_CH_TYPE_SECTION},
    {0x12,0x56,NULL,40960,0,DMX_CH_TYPE_SECTION},
    {0x12,0x57,NULL,40960,0,DMX_CH_TYPE_SECTION},
    {0x12,0x58,NULL,40960,0,DMX_CH_TYPE_SECTION},
    {0x12,0x59,NULL,40960,0,DMX_CH_TYPE_SECTION},
    {0x12,0x5a,NULL,40960,0,DMX_CH_TYPE_SECTION},
    {0x12,0x5b,NULL,40960,0,DMX_CH_TYPE_SECTION},
    {0x12,0x5c,NULL,40960,0,DMX_CH_TYPE_SECTION},
    {0x12,0x5d,NULL,40960,0,DMX_CH_TYPE_SECTION},
    {0x12,0x5f,NULL,40960,0,DMX_CH_TYPE_SECTION},
    {0x12,0x6f,NULL,40960,0,DMX_CH_TYPE_SECTION},
    {0x12,0x61,NULL,40960,0,DMX_CH_TYPE_SECTION},
    {0x12,0x62,NULL,40960,0,DMX_CH_TYPE_SECTION},
    {0x12,0x63,NULL,40960,0,DMX_CH_TYPE_SECTION},
    {0x12,0x64,NULL,40960,0,DMX_CH_TYPE_SECTION},
    {0x12,0x65,NULL,40960,0,DMX_CH_TYPE_SECTION},
    {0x12,0x66,NULL,40960,0,DMX_CH_TYPE_SECTION},
    {0x12,0x67,NULL,40960,0,DMX_CH_TYPE_SECTION},
    {0x12,0x68,NULL,40960,0,DMX_CH_TYPE_SECTION},
    {0x12,0x69,NULL,40960,0,DMX_CH_TYPE_SECTION},
    {0x12,0x6a,NULL,40960,0,DMX_CH_TYPE_SECTION},
    {0x12,0x6b,NULL,40960,0,DMX_CH_TYPE_SECTION},
    {0x12,0x6c,NULL,40960,0,DMX_CH_TYPE_SECTION},
    {0x12,0x6d,NULL,40960,0,DMX_CH_TYPE_SECTION},
    {0x12,0x6e,NULL,40960,0,DMX_CH_TYPE_SECTION},
    #endif
    //{0x12,0x60,NULL,1024*5,0,DMX_CH_TYPE_SECTION}
};

static dmx_input_type_t stream_input_port = DMX_INPUT_EXTERN0;

//static u8 even_key[8] = {0x00,0x00,0x00,0x00,0x00,0x07,0x86,0x8D};
//static u8 odd_key[8] = {0x00,0x00,0x00,0x00,0x00,0x07,0x86,0x8D};

//static u8 even_key[8] = {0x12,0x31,0x23,0x66,0x12,0x31,0x23,0x66};
//static u8 odd_key[8] = {0x12,0x31,0x23,0x66,0x12,0x31,0x23,0x66};

static u8 even_key[8] = {0};
static u8 odd_key[8] = {0};

static dmx_chanid_t video_chan = 0xffff;
static dmx_chanid_t audio_chan = 0xffff;
static dmx_chanid_t pcr_chan = 0xffff;
static u32 dmx_cmd_msg_handle = 0;

#ifdef WARRIORS
static dmx_chanid_t rec_video_chan = 0xffff;
static dmx_chanid_t rec_audio_chan = 0xffff;
static dmx_chanid_t rec_pcr_chan = 0xffff;

static BOOL rec_play_flag = FALSE;
static u16   rec_ts_clk = 0xffff;
u8   *p_rec_play_buf = NULL;
static u32 rec_play_total_size = 0;

static u32 rec_threshold_size = 0;
static u32 rec_location_size = 0;
static u32 play_location_size = 0;
#endif

extern void mtos_task_delay_ms(u32 ms);

static void parse_pat_section(u8 *p_buf);
static void parse_pmt_section(u8 *p_buf);
static void parse_sdt_section(u8 *p_buf);
static BOOL alloc_pat_section();
static BOOL alloc_pmt_section(u16 pid, u16 lbn);
static BOOL alloc_sdt_section(u16 sec_number);
static void dmx_start_play(u32 vpid,u32 apid, u32 pcrpid);
static void dmx_stop_play();

static u8* dmx_memory_malloc(u32 buf_size)
{
   u32 buf;
#ifdef  WARRIORS
   buf =(u32) mtos_align_nc_malloc(buf_size ,64);    //memory align
#elif ORCHID
   buf =(u32) mtos_malloc(buf_size + 7);    //memory align
#else
   buf =(u32) mtos_align_malloc(buf_size , 16);
#endif

   return (u8 *)buf;
}

static void dmx_memory_free(u8* addr)
{
#ifdef WARRIORS
    mtos_align_nc_free(addr);
#elif ORCHID
   mtos_free(addr);
#else
    mtos_align_free(addr);
#endif
}

static void cmd_dmx_help(void)
{
  OS_PRINTF("\n");
  OS_PRINTF("This module must rely on nim to work.so you must open the device of nim firstly\n");
  OS_PRINTF("      -d     dmx_si_channel_test : dmx -d pid input_port type mode size\n");
  OS_PRINTF("                     param1 : pid \n");
  OS_PRINTF("                     param2 : input_port 0:TS0 1:TS1 2:TS_CI 3:TS_DMA\n");
  OS_PRINTF("                                     (This parameter is only used for warriors chip,\n");
  OS_PRINTF("                                      magic platform can set any value,don't care!)\n");
  OS_PRINTF("                     param3 : type  0:Section 1:TS_PACKET\n");
  OS_PRINTF("                     param4 : mode 1:continue mode 0:single mode\n");
  OS_PRINTF("                     param5 :  size :The Buffer Size\n");
  OS_PRINTF("      \n");

  OS_PRINTF("      -t     dmx_chan_test: dmx -t\n");
#ifdef WARRIORS
  OS_PRINTF("      -i     dmx stream input select : dmx -i stream_input\n");
  OS_PRINTF("                      stream_input  0:DMX_INPUT_EXTERN0\n");
  OS_PRINTF("                      stream_input  1:DMX_INPUT_EXTERN1\n");
  OS_PRINTF("                      stream_input  2:DMX_INPUT_EXTERN_CI\n");
  OS_PRINTF("                      stream_input  3:DMX_INPUT_EXTERN_DMA\n");

  OS_PRINTF("      -r     dmx rec data test : dmx -r port type size pid... \n");
  OS_PRINTF("                     param1 : port  0:rec0_port 1:rec1_port\n");
  OS_PRINTF("                     param2 : type  0:Full TS with NULL Packet\n");
  OS_PRINTF("                                     1:Full TS withOUT NULL Packet\n");
  OS_PRINTF("                                     2:Partial TS Packet\n");
  OS_PRINTF("                     param3   : size  The Buffer Size (Unit: 188*10)\n");
  OS_PRINTF("                                      the circle range max is 127 unit\n");
  OS_PRINTF("                     param4...: pid    Max pid number is 128\n");
  OS_PRINTF("      \n");
  OS_PRINTF("      -a     dmx dma test(show logo) : dmx -a\n");
#endif
#ifdef ORCHID
  OS_PRINTF("      -u     dmx pes test: dmx -u pes_pid, pcr_pid,pes_type\n");
  OS_PRINTF("                      pes_type  0: video pes, 1,audop pes, 2 other\n");
#endif
  OS_PRINTF("      -p     dmx tp parser test: dmx -p\n");
  OS_PRINTF("      -s     dmx set vid/audio/pcr pid: dmx -s vid aid pcr\n");
  OS_PRINTF("      -q     dmx stop the av play: dmx -q\n");
  OS_PRINTF("      -h     dmx help\n");
  OS_PRINTF("      -z     dmx receive data : dmx -d pid type\n");
  OS_PRINTF("                   pid             PID value of TS stream\n");
  OS_PRINTF("                   type            0:Section 1:TS_PACKET\n");
  OS_PRINTF("      \n");
  OS_PRINTF("Examples:\n");
  OS_PRINTF("1. dmx -d 100 0 1 1 4096\n");
  OS_PRINTF("  describtion:This cmd will recevie data of the partial pid \n");
  OS_PRINTF("2. dmx -s 100 101 100\n");
  OS_PRINTF("  describtion:This cmd will play the programe\n");
  OS_PRINTF("3. dmx -q\n");
  OS_PRINTF("  describtion:This cmd stop play the av\n");
}

static void init_filter(void)
{
    u32 i;
    for (i = 0; i< FILTER_NUM; i ++)
        filters[i].handle = 0xffff;
}

static filter_attr_t* search_free_filter(void)
{
    u32 i;
    for (i = 0; i< FILTER_NUM; i ++)
    {
        if (filters[i].handle == 0xffff)
            return filters + i;
    }

    return NULL;
}

static void parse_pat_section(u8 *p_buf)
{
  u16 section_len;
  u16 prog_no;
  u16 pmt_pid;
  //byte2_t ts_id;
  s16 program_len;
  u8 *p_ptr = NULL;
  pat_t pat;

  //MT_ASSERT(NULL != p_buf);

  //MT_ASSERT(DVB_TABLE_ID_PAT == p_buf[0]);
  memset(&pat, 0, sizeof(pat_t));

  /* get section length */
  //section_len.Byte[1] = p_buf[1] & 0x0F;
  //section_len.Byte[0] = p_buf[2];
  section_len = MAKE_WORD(p_buf[2],p_buf[1] & 0x0F);
  section_len += 3;

  if ((p_buf[5] & 0x01) == 0)
  {
    OS_PRINTF("This PAT is not usable!!!\n");
    return; /* this PAT is not usable */
  }

  //ts_id.Byte[0] = p_buf[3];
  //ts_id.Byte[1] = p_buf[4];
  //pat.ts_id = ts_id.Short;

  program_len = (section_len - 8 - 4);

  pat.prog_num = 0;
  p_ptr = &p_buf[8];

  while (program_len > 0)
  {
    /* get program number */
    //prog_no.Byte[1] = p_ptr[0];
    //prog_no.Byte[0] = p_ptr[1];
    prog_no = MAKE_WORD(p_ptr[1], p_ptr[0]);

    /* get program map pid */
    //pmt_pid.Byte[1] = p_ptr[2] & 0x1f;
    //pmt_pid.Byte[0] = p_ptr[3];
    pmt_pid = MAKE_WORD(p_ptr[3], p_ptr[2] & 0x1f);


    if (0 == prog_no)
    {
      /* get network table pid */
      //pat.nit_pid = pmt_pid.Short;
    }
    else if (0xfffe != prog_no)
    {
      /* get program number and map table pid*/
      //pat.progs[pat.prog_num].lbn = prog_no.Short;
      pat.progs[pat.prog_num].pmt_pid = pmt_pid;
      pat.prog_num++;
      if(1)
      {
         alloc_pmt_section(pmt_pid, prog_no);
      }
      OS_PRINTF("\t total pmt num: %d pid = %d\n", pat.prog_num,pmt_pid);
    }

    if (pat.prog_num >= DVB_MAX_PAT_PROG_NUM)
    {
      break;
    }

    program_len -= 4;
    p_ptr += 4;
  }

  OS_PRINTF("\r\nparsing pat over.");
  return;
}

static void parse_pmt_section(u8 *p_buf)
{
  u8 *p;
  u8 stream_type;
  u16 element_pid;
  s16 section_len;
  s16 prog_info_Len;
  s16 es_info_len;
  u16 desc_len;
  pmt_t pmt;
  u32 ecm_pid;

  if (p_buf[0] != DVB_TABLE_ID_PMT)
  {
    OS_PRINTF("\r\nMDL: not pmt");
    return;
  }

  if ((p_buf[5] & 0x01) == 0)
  {
    OS_PRINTF("\r\nMDL: this pmt is not usable");
    return;
  }

  memset(&pmt, 0, sizeof(pmt_t));

  /* Section length */
  //tmp_short.Byte[1] = p_buf[1] & 0x0f;
  //tmp_short.Byte[0] = p_buf[2];
  //section_len = tmp_short.Short + 3;
  section_len = MAKE_WORD(p_buf[2], p_buf[1] & 0x0f) + 3;

  /* Program number */
  //tmp_short.Byte[1] = p_buf[3];
  //tmp_short.Byte[0] = p_buf[4];
  //pmt.prog_num = tmp_short.Short;
  pmt.prog_num = MAKE_WORD(p_buf[4], p_buf[3]);
  OS_PRINTF("\r\n\tMDL: program number: %d", pmt.prog_num);

  /* Pcr pid */
  //tmp_short.Byte[1] = p_buf[8] & 0x1f;
  //tmp_short.Byte[0] = p_buf[9];
  //pmt.pcr_pid = tmp_short.Short;
  pmt.prog_num = MAKE_WORD(p_buf[9], p_buf[8] & 0x1f);
  OS_PRINTF("\r\n\t\tpcr_pid= %d", pmt.prog_num);

  /* program info length */
  //tmp_short.Byte[1] = p_buf[10] & 0x0f;
  //tmp_short.Byte[0] = p_buf[11];
  prog_info_Len = MAKE_WORD(p_buf[11], p_buf[10] & 0x0f);
  section_len -= (12 + 4);
  p = &p_buf[12];

  ecm_pid = 0;
  if (prog_info_Len > 0)
  {
    section_len -= prog_info_Len;

    while (prog_info_Len > 0)
    {
      desc_len = p[1] + 2;
      switch (p[0])
      {
        case DVB_DESC_CA:                          /* get ECM or EMM pid */
          //pmt.is_ca_enable = 1;
          ecm_pid = ((p[4] & 0x1F) << 8) | p[5];
          //alloc_ecm_section(ecm_pid, DVB_TABLE_ID_ECM);
          //alloc_ecm_section(ecm_pid, DVB_TABLE_ID_ECM);
          OS_PRINTF("\r\n---------TS: ECM_PID = %d", ecm_pid);
          break;
          /*        case DVB_DESC_DVB_STREAM_IDENTIFIER:
             break;

             case DVB_DESC_SYSTEM_CLOCK:
             break;*/

        default:
          break;
      }
      prog_info_Len -= desc_len;
      p += desc_len;
    }
  }
  /* get ES pid */
  pmt.audio_count = 0;

  while (section_len > 0)
  {
    /*Stream_type*/
    stream_type = p[0];
    /* PID */
    //tmp_short.Byte[1] = p[1] & 0x1f;
    //tmp_short.Byte[0] = p[2];
    element_pid = MAKE_WORD(p[2], p[1] & 0x0f);

    switch (stream_type)
    {
      case DVB_STREAM_MG2_VIDEO:
      case DVB_STREAM_MG1_VIDEO:
        pmt.video_pid = element_pid;
        OS_PRINTF("\r\n\t\tvideo_pid=%d", element_pid);
        break;
      case DVB_STREAM_MG1_AUDIO:
      case DVB_STREAM_MG2_AUDIO:
        if (pmt.audio_count < DVB_MAX_AUDIO_PID_NUM)
        {
          pmt.audio[pmt.audio_count].p_id = element_pid;
          pmt.audio_count++;
        }
        OS_PRINTF("\r\n\t\taudio_pid=%d", element_pid);
        break;

      case DVB_STREAM_PESRIVA_SEC:
        break;

      case DVB_STREAM_PRIVATE_SEC:
        OS_PRINTF("\r\n\t\t DVB_STREAM_PRIVATE_SEC PID = %d", element_pid);
        break;

      case DVB_STREAM_OTA_SEC:
        OS_PRINTF("\r\n---------PID of ota = %d", element_pid);
        break;

      default:
        break;
    }

    /* ES info len*/
    //tmp_short.Byte[1] = p[3] & 0x0f;
    //tmp_short.Byte[0] = p[4];
    es_info_len = MAKE_WORD(p[4], p[3] & 0x0f);

    section_len -= (es_info_len + 5);
    p += 5;

    while (es_info_len > 0)
    {
      desc_len = p[0] + 2;
      switch (p[1])
      {
        case DVB_DESC_CA:
          ecm_pid = ((p[4] & 0x1F) << 8) | p[5];
          //alloc_ecm_section(ecm_pid, DVB_TABLE_ID_ECM);
          //alloc_ecm_section(ecm_pid, DVB_TABLE_ID_ECM);
          OS_PRINTF("\r\n---------PES: ECM_PID = %d", ecm_pid);
          break;
        case DVB_DESC_STREAM_IDENTIFIER:
          break;
      }

      es_info_len -= desc_len;
      p += desc_len;
    }
  }

  OS_PRINTF("\r\nparsing pmt over.");
  return;
}

static void parse_sdt_section(u8 *p_buf)
{
  u8                    *p;
  s16                   section_len;
  s16                   desc_loop_len;
  s16                   service_len;
  u8                    desc_len;
  u8                    ver_number;
  u16                   onet_id;
  sdt_t                 sdt = {0};
  sdt_svc_descriptor_t  *p_svc = NULL;

  if (p_buf[0] != DVB_TABLE_ID_SDT_ACTUAL)
  {
    OS_PRINTF("MDL: not sdt section, %d\n", p_buf[0]);
    return;
  }

  if ((p_buf[5] & 0x01) == 0)
  {
    OS_PRINTF("MDL: this sdt is not usable\n");
    return;
  }

  ver_number = (p_buf[5] & 0x3E) >> 1;

  /* Section length */
  //tmp_short.Byte[1] = p_buf[1] & 0x0f;
  //tmp_short.Byte[0] = p_buf[2];
  section_len = MAKE_WORD(p_buf[2], p_buf[1] & 0x0f);
  /* Transport stream id */
  //tmp_short.Byte[1] = p_buf[3];
  //tmp_short.Byte[0] = p_buf[4];
  //sdt.ts_id = tmp_short.Short;

  sdt.sec_number = p_buf[6];
  sdt.last_sec_number = p_buf[7];

  /* original network id */
  //tmp_short.Byte[1] = p_buf[8];
  //tmp_short.Byte[0] = p_buf[9];
  onet_id = MAKE_WORD(p_buf[9], p_buf[8]);

  p = &p_buf[11];
  service_len = section_len - 11 - 4;

  sdt.svc_count = 0;

  OS_PRINTF("MDL: section_len %d\n", section_len);
  OS_PRINTF("MDL: service_len %d\n", service_len);
  //OS_PRINTF("MDL: ts_id %d\n", sdt.ts_id);
  OS_PRINTF("MDL: SDT sec number: %d, last sec number: %d\n",
            sdt.sec_number, sdt.last_sec_number);

  while (service_len > 0)
  {
    p_svc = &sdt.svc_des[sdt.svc_count];

    //tmp_short.Byte[1] = p[0];
    //tmp_short.Byte[0] = p[1];
    p_svc->svc_id = MAKE_WORD(p[1], p[0]);
    OS_PRINTF("MDL: svc id: %d\n", p_svc->svc_id);

    /* description loop length */
    //tmp_short.Byte[1] = p[3] & 0x0f;
    //tmp_short.Byte[0] = p[4];
    desc_loop_len = MAKE_WORD(p[4], p[3] & 0x0f);

    OS_PRINTF("MDL: desc_loop_len: %d\n", desc_loop_len);
    if (desc_loop_len < 0)
    {
      // This should not happen but it maybe happen because of bad signal
      break;
    }

    p += 5;
    service_len -= (desc_loop_len + 5);
    OS_PRINTF("MDL: service_len: %d\n", service_len);

    while (desc_loop_len > 0)
    {
      desc_len = p[0] + 2;
      switch (p[1])
      {
        case DVB_DESC_SERVICE:
          OS_PRINTF("MDL: parse desc svc\n");
          //parse_desc_svc(p, p_svc);
          break;

        case DVB_DESC_ML_SVCNAME:
          //parse_desc_ml_svc(p, p_svc);
          OS_PRINTF(("MDL: parse desc ml svc\n"));
          break;
        case DVB_DESC_NVOD_REFERENCE:
          break;

        case DVB_DESC_TIME_SHIFTED_SERVICE:
          break;
      }

      OS_PRINTF("MDL: desc_len: %d\n", desc_len);
      p += desc_len;
      desc_loop_len -= desc_len;
    }

    sdt.svc_count++;
    if (sdt.svc_count >= DVB_MAX_SDT_SVC_NUM)
    {
      break;
    }
  }

  OS_PRINTF("MDL: total %d svc count in this sdt\n", sdt.svc_count);

  if (sdt.sec_number < sdt.last_sec_number)
  {
    alloc_sdt_section(sdt.sec_number + 1);
  }

  OS_PRINTF("\r\nparsing sdt over.");
  return;
}

static BOOL alloc_pat_section(void)
{
    RET_CODE dmx_ret = ERR_FAILURE;
    dmx_filter_setting_t *p_param = NULL;
    dmx_slot_setting_t   *p_slot = NULL;
    dmx_device_t* p_dev    = NULL;

    filter_attr_t *p_filter = search_free_filter();

    p_dev = (dmx_device_t *)dev_find_identifier(NULL
            , DEV_IDT_TYPE, SYS_DEV_TYPE_PTI);
    MT_ASSERT(NULL != p_dev->p_base);

    if (p_filter == NULL)
        return FALSE;

    OS_PRINTF("requesting a PAT section\n");

    p_param = &p_filter->alloc_param;
    p_slot  = &p_filter->slot_t;

    p_slot->in = DMX_INPUT_EXTERN0;
    p_slot->pid = DVB_PAT_PID;
    p_slot->type = DMX_CH_TYPE_SECTION;

    dmx_ret = dmx_si_chan_open(p_dev,p_slot,&p_filter->handle);
    if(dmx_ret != SUCCESS)
    {
      OS_PRINTF("open si channel failed!\n");
      return FALSE;
    }

    p_filter->p_buf = (u8*)dmx_memory_malloc(FILTER_BUFFER_SIZE);

    //p_filter->p_buf = (u8 *)(0xa2800000);
    MT_ASSERT(p_filter->p_buf != NULL);

    OS_PRINTF("buf address 0x%08x\n",p_filter->p_buf);
    dmx_ret= dmx_si_chan_set_buffer(p_dev,p_filter->handle,p_filter->p_buf,FILTER_BUFFER_SIZE);
    if(dmx_ret!=SUCCESS)
    {
      OS_PRINTF("set filter buffer failed!\n");
      return FALSE;
    }

    p_param->continuous = FALSE;
    p_param->en_crc = TRUE;
    memset(p_param->value,0x00,DMX_SECTION_FILTER_SIZE);
    memset(p_param->mask,0x00,DMX_SECTION_FILTER_SIZE);
    p_param->value[0] = DVB_TABLE_ID_PAT;
    p_param->mask[0] = 0xff;
    dmx_ret=dmx_si_chan_set_filter(p_dev,p_filter->handle,p_param);
    if(dmx_ret!=SUCCESS)
    {
      OS_PRINTF("set filter failed!\n");
      return FALSE;
    }

    p_filter->table_id = DVB_TABLE_ID_PAT;
    p_filter->parser = parse_pat_section;

    dmx_ret=dmx_chan_start(p_dev,p_filter->handle);
    if(dmx_ret!=SUCCESS)
    {
      OS_PRINTF("start channel  failed!\n");
      return FALSE;
    }

    return TRUE;
}

static BOOL alloc_sdt_section(u16 sec_number)
{
    RET_CODE dmx_ret = ERR_FAILURE;
    dmx_filter_setting_t *p_param = NULL;
    dmx_slot_setting_t   *p_slot = NULL;
    dmx_device_t* p_dev    = NULL;

    filter_attr_t *p_filter = search_free_filter();

    p_dev = (dmx_device_t *)dev_find_identifier(NULL
            , DEV_IDT_TYPE, SYS_DEV_TYPE_PTI);
    MT_ASSERT(NULL != p_dev->p_base);

    if (p_filter == NULL)
        return FALSE;

    OS_PRINTF("requesting a SDT section\n");

    p_param = &p_filter->alloc_param;
    p_slot  = &p_filter->slot_t;

    p_slot->in = DMX_INPUT_EXTERN0;
    p_slot->pid = DVB_SDT_PID;
    p_slot->type = DMX_CH_TYPE_SECTION;

    dmx_ret = dmx_si_chan_open(p_dev,p_slot,&p_filter->handle);
    if(dmx_ret != SUCCESS)
    {
      OS_PRINTF("open si channel failed!\n");
      return FALSE;
    }

    p_filter->p_buf =(u8*)dmx_memory_malloc(4096);
    MT_ASSERT(p_filter->p_buf != NULL);

    OS_PRINTF("buf address 0x%08x\n",p_filter->p_buf);
    dmx_ret= dmx_si_chan_set_buffer(p_dev,p_filter->handle,p_filter->p_buf,4096);
    if(dmx_ret!=SUCCESS)
    {
      OS_PRINTF("set filter buffer failed!\n");
      return FALSE;
    }

    p_param->continuous = TRUE;
    p_param->en_crc = TRUE;
    memset(p_param->value,0x00,DMX_SECTION_FILTER_SIZE);
    memset(p_param->mask,0x00,DMX_SECTION_FILTER_SIZE);
    p_param->value[0] = DVB_TABLE_ID_SDT_ACTUAL;
    p_param->mask[0] = 0xFF;
    p_param->value[4] = (u8)sec_number;
    p_param->mask[4] = 0xFF;
    dmx_ret=dmx_si_chan_set_filter(p_dev,p_filter->handle,p_param);
    if(dmx_ret!=SUCCESS)
    {
      OS_PRINTF("set filter failed!\n");
      return FALSE;
    }

    p_filter->table_id = DVB_TABLE_ID_SDT_ACTUAL;
    p_filter->parser = parse_sdt_section;

    dmx_ret=dmx_chan_start(p_dev,p_filter->handle);
    if(dmx_ret!=SUCCESS)
    {
      OS_PRINTF("start channel  failed!\n");
      return FALSE;
    }

    return TRUE;
}

static BOOL alloc_pmt_section(u16 pid, u16 lbn)
{
    RET_CODE dmx_ret = ERR_FAILURE;
    dmx_filter_setting_t *p_param = NULL;
    dmx_slot_setting_t   *p_slot = NULL;
    dmx_device_t* p_dev    = NULL;

    filter_attr_t *p_filter = search_free_filter();

    p_dev = (dmx_device_t *)dev_find_identifier(NULL
            , DEV_IDT_TYPE, SYS_DEV_TYPE_PTI);
    MT_ASSERT(NULL != p_dev->p_base);

    if (p_filter == NULL)
        return FALSE;

    OS_PRINTF("requesting a PMT section\n");

    p_param = &p_filter->alloc_param;
    p_slot  = &p_filter->slot_t;

    p_slot->in = DMX_INPUT_EXTERN0;
    p_slot->pid = pid;
    p_slot->type = DMX_CH_TYPE_SECTION;

    dmx_ret = dmx_si_chan_open(p_dev,p_slot,&p_filter->handle);
    if(dmx_ret != SUCCESS)
    {
      OS_PRINTF("open si channel failed!\n");
      return FALSE;
    }

    p_filter->p_buf =(u8*)dmx_memory_malloc(FILTER_BUFFER_SIZE);

    MT_ASSERT(p_filter->p_buf != NULL);

    OS_PRINTF("buf address 0x%08x\n",p_filter->p_buf);
    dmx_ret= dmx_si_chan_set_buffer(p_dev,p_filter->handle,p_filter->p_buf,FILTER_BUFFER_SIZE);
    if(dmx_ret!=SUCCESS)
    {
      OS_PRINTF("set filter buffer failed!\n");
      return FALSE;
    }

    p_param->continuous = FALSE;
    p_param->en_crc = TRUE;
    memset(p_param->value,0x00,DMX_SECTION_FILTER_SIZE);
    memset(p_param->mask,0x00,DMX_SECTION_FILTER_SIZE);

    p_param->value[0] = DVB_TABLE_ID_PMT;
    p_param->mask[0] = 0xFF;
    p_param->value[1] = lbn >> 8;
    p_param->mask[1] = 0xFF;
    p_param->value[2] = lbn & 0xFF;
    p_param->mask[2] = 0xFF;

    dmx_ret=dmx_si_chan_set_filter(p_dev,p_filter->handle,p_param);
    if(dmx_ret!=SUCCESS)
    {
      OS_PRINTF("set filter failed!\n");
      return FALSE;
    }

    #if 1
    p_filter->table_id = DVB_TABLE_ID_PMT;
    p_filter->parser = parse_pmt_section;

    dmx_ret=dmx_chan_start(p_dev,p_filter->handle);
    if(dmx_ret!=SUCCESS)
    {
      OS_PRINTF("start channel  failed!\n");
      return FALSE;
    }
    #endif
    return TRUE;
}

static void dmx_tp_parse()
{
  RET_CODE ret = 0;
  u32         i = 0 , j= 0;
  u32 ticks = 0;
  u32         cnt = 0;
  dmx_device_t* p_dev    = NULL;

  p_dev = (dmx_device_t *)dev_find_identifier(NULL
          , DEV_IDT_TYPE, SYS_DEV_TYPE_PTI);
  MT_ASSERT(NULL != p_dev->p_base);

  init_filter();

  //alloc_sdt_section(0);
  alloc_pat_section();

  while(1)
  {
        u32 empty = 0;
        for (i = 0; i < FILTER_NUM; i++)
        {
            if (0xffff != filters[i].handle)
            {
                OS_PRINTF("[%d]: pid=%d, table_id=%d\n",
                      i,
                    filters[i].slot_t.pid,
                    filters[i].table_id);
            }
            else
            {
                empty++;
            }
        }
         if (empty >= FILTER_NUM)
        {
            OS_PRINTF("Parsing for current TP is finished.\n");
            TESTFM_SETRESULT(RET_SUCCESS, 0x2a, FALSE);
            return;
        }
        OS_PRINTF("Waiting for sections .");
        ticks = mtos_ticks_get();
        cnt = 0;
        while (cnt ++ < 300)
        {
            for (i = 0; i < FILTER_NUM; i++)
            {
                if (filters[i].handle != 0xffff)
                {
                    ret=dmx_si_chan_get_data(p_dev, filters[i].handle, &filters[i].p_data, &filters[i].size);
                    if (ret != ERR_NO_RSRC)
                        break;
                }
            }

            if (i < FILTER_NUM)
            {
                if(ret == ERR_STATUS)
                {
                  OS_PRINTK(">>>parse crc error data!!!\n");
                  continue;
                }
                else
                  break;
            }
            if (mtos_ticks_get() - ticks > 500)
                break;

            OS_PRINTF(".");
            mtos_task_sleep(50);
        }

        if (mtos_ticks_get() - ticks > 500 || cnt >= 300)
        {
            OS_PRINTF("timeout\n");
            //print_filter_info(p_pti_cb);
            for (i=0; i<FILTER_NUM; i++)
            {
                if (filters[i].handle == 0xffff)
                    continue;

                ret=dmx_chan_stop(p_dev, filters[i].handle);
                MT_ASSERT(ret==SUCCESS);

                ret=dmx_chan_close(p_dev, filters[i].handle);
                MT_ASSERT(ret==SUCCESS);

                //if(filters[i].p_buf != (u8 *)0xa2800000)
                dmx_memory_free(filters[i].p_buf);
                filters[i].p_buf = NULL;
                filters[i].handle = 0xffff;
            }
            TESTFM_SETRESULT(RET_FAIL, 0x10, FALSE);
            return;
        }

        #if 1
        OS_PRINTF("\n");
        OS_PRINTF("new section: table_id=%d, len = %d\n",filters[i].table_id, filters[i].size);
        OS_PRINTF("       data: ");
        for(j = 0;j < filters[i].size; j++)
          OS_PRINTF("%02x ", filters[i].p_data[j]);
        OS_PRINTF("\n");
        #endif

        switch (filters[i].table_id)
        {
            case DVB_TABLE_ID_PAT:
                parse_pat_section(filters[i].p_data);
                OS_PRINTF("\n");
                for(j = 0;j < filters[i].size; j++)
                    OS_PRINTF("%02x ", filters[i].p_data[j]);
              break;
            case DVB_TABLE_ID_PMT:
                parse_pmt_section(filters[i].p_data);
                break;
            case DVB_TABLE_ID_SDT_ACTUAL:
                parse_sdt_section(filters[i].p_data);
                break;
            case DVB_TABLE_ID_EIT_ACTUAL:
            case DVB_TABLE_ID_EIT_OTHER:
            case DVB_TABLE_ID_EIT_SCH_ACTUAL:
            case DVB_TABLE_ID_EIT_SCH_OTHER:
                if (0)
                {
                    OS_PRINTF("parse eit, table id is 0x%x\n", filters[i].table_id);
                    //parse_eit_section(block.p_data);
                }
                break;
            default:
                //MT_ASSERT(0);
                break;
        }

        ret=dmx_chan_stop(p_dev, filters[i].handle);
        MT_ASSERT(ret==SUCCESS);

        ret=dmx_chan_close(p_dev, filters[i].handle);
        MT_ASSERT(ret==SUCCESS);

        dmx_memory_free(filters[i].p_buf );
        filters[i].p_buf = NULL;
        filters[i].handle = 0xffff;
  }

  TESTFM_SETRESULT(RET_SUCCESS, 0x2a, FALSE);
}

void check_data_info(u8 *p_data, u32 size)
{
        u8 i = 0;
        u8 count = 0;
        u8 last_cc = 0;
        u8 cur_cc = 0;
        BOOL first_flag = TRUE;

        MT_ASSERT((size%188) == 0);

        for(count = 0; count < size/188; count++)
        {
            #if 1
            //OS_PRINTF("pid 0x%02x Table[%08x] len[%d]:",p_data[0], p_data[5],size);
            for(i=0;i<5;i++)
              OS_PRINTF("%02x ",p_data[i]);
            OS_PRINTF("\n");
            #endif
            cur_cc = (p_data[3])&0x0f;
            if(first_flag == TRUE)
            {
                last_cc = cur_cc;
                first_flag = FALSE;
            }
            else
            {
                p_data += 188;
                if(((last_cc + 1)%16) == cur_cc)
                {
                    last_cc = cur_cc;
                    continue;
                }
                else
                {
                    OS_PRINTF("cc is not correct [%d]\n",i);
                    //break;
                }
             }
         }
}

static u32 dmx_rece_count = 0;
static void dmx_si_channel_set(u32 pid,
                                                            u32 dmx_input,
                                                            u32 dmx_channel_type,
                                                            u32 mode,
                                                            u32 buf_size,
                                                            u32 table_id)
{
  u32 i = 0;
  u32 times = dmx_timeout * 4000;
  RET_CODE ret;
  RET_CODE dmx_ret = ERR_FAILURE;
  dmx_chanid_t  si_channel_id;
  dmx_device_t* p_dev    = NULL;
  dmx_slot_setting_t slot_t;
  dmx_filter_setting_t  filter_param_t;
  u8 *p_buf = NULL;
  u8 *p_data = NULL;
  u32 size = 0;
  u32 length = 0;

  p_dev = (dmx_device_t *)dev_find_identifier(NULL
          , DEV_IDT_TYPE, SYS_DEV_TYPE_PTI);
  MT_ASSERT(NULL != p_dev->p_base);

   OS_PRINTF(">>>dmx input %d \n",dmx_input);
  slot_t.in     = dmx_input;
  slot_t.pid   = pid;
  slot_t.type = dmx_channel_type;
  dmx_ret=dmx_si_chan_open(p_dev,&slot_t,&si_channel_id);
  if(dmx_ret!=SUCCESS)
  {
    OS_PRINTF("open si channel failed!\n");
    TESTFM_SETRESULT(RET_FAIL, 0x10, FALSE);
    return;
  }

  if(buf_size <= 188)
  {
      OS_PRINTF("buf size set error!!!\n");
      TESTFM_SETRESULT(RET_FAIL, 0x10, FALSE);
      return;
  }
  if(dmx_channel_type == DMX_CH_TYPE_TSPKT)
    buf_size = buf_size * 188;

  p_buf =(u8*)dmx_memory_malloc(buf_size );
  MT_ASSERT(p_buf != NULL);

  OS_PRINTF("buf address 0x%08x\n",p_buf);
  dmx_ret= dmx_si_chan_set_buffer(p_dev,si_channel_id,p_buf,buf_size);
  if(dmx_ret!=SUCCESS)
  {
    OS_PRINTF("set filter buffer failed!\n");
    TESTFM_SETRESULT(RET_FAIL, 0x10, FALSE);
    return;
  }

  filter_param_t.continuous = mode;
  if(pid == 0x14)
    filter_param_t.en_crc = FALSE;
  else
    filter_param_t.en_crc = TRUE;
  filter_param_t.ts_packet_mode = DMX_FIVE_MODE;

  memset(filter_param_t.value,0x00,DMX_SECTION_FILTER_SIZE);
  memset(filter_param_t.mask,0x00,DMX_SECTION_FILTER_SIZE);

  //if(pid == 0x12)
  {
      if( table_id != 0) 
      {
          filter_param_t.value[0]=table_id;
          filter_param_t.mask[0]=0xff;
      }
  }

  //filter_param_t.value[0]=0;
  //filter_param_t.mask[0]=0xff;

  dmx_ret=dmx_si_chan_set_filter(p_dev,si_channel_id,&filter_param_t);
  if(dmx_ret!=SUCCESS)
  {
    OS_PRINTF("set filter failed!\n");
    TESTFM_SETRESULT(RET_FAIL, 0x10, FALSE);
    return;
  }

  dmx_ret=dmx_chan_start(p_dev,si_channel_id);
  if(dmx_ret!=SUCCESS)
  {
    OS_PRINTF("start channel  failed!\n");
    TESTFM_SETRESULT(RET_FAIL, 0x10, FALSE);
    return;
  }

  while(1)
  {
      ret=dmx_si_chan_get_data(p_dev, si_channel_id, &p_data, &size);
      if(ret != ERR_NO_RSRC )
      {
        if(ret == ERR_STATUS)
          OS_PRINTF("Get crc error data:addr [0x%08x] len[%d]!!!\n",p_data,size);

        length += size;

        if(dmx_channel_type == DMX_CH_TYPE_TSPKT)
        {
            check_data_info(p_data,size);
            if(mode == FALSE)  //single mode
              break;
            else if(++dmx_rece_count >= 100)
            {
                OS_PRINTF("count up to 100!!!\n");     
                break;
            }
            continue;
        }
        else
        {
            #if 1
            OS_PRINTF("[%d] pid 0x%02x Table[%08x] len[%d]:",length,pid,p_data,size);
            for(i=0;i<size;i++)
              OS_PRINTF("%02x ",p_data[i]);
            OS_PRINTF("\n");
            if((u32)p_data[0] != table_id)
            {
              TESTFM_SETRESULT(RET_FAIL, 0x2b, FALSE);
              return;
            }
            #endif
        }

        if(mode == FALSE)  //single mode
          break;

     }

    if((--times) ==0)
    {
        OS_PRINTF("time out!!!\n");
        break;
    }

    if(ret != SUCCESS)
        #ifndef __LINUX__
		mtos_task_delay_ms(1);
		#else
        usleep(1000);
		#endif
    else
    {
        #if 1
        if(++dmx_rece_count >= 100)
        {
            OS_PRINTF("count up to 100!!!\n");     
            break;
        }
        #endif
    }

    //OS_PRINTF("[%d].",times);
    //if(pid != 0x12)
    //  mtos_task_delay_ms(50);
  }

  OS_PRINTF("\n");

  ret=dmx_chan_stop(p_dev, si_channel_id);
  MT_ASSERT(ret==SUCCESS);

  ret=dmx_chan_close(p_dev, si_channel_id);
  MT_ASSERT(ret==SUCCESS);

  dmx_memory_free(p_buf);
  OS_PRINTF("channel test finished!\n");
  dmx_rece_count = 0;
  TESTFM_SETRESULT(RET_SUCCESS, 0x2a, FALSE);
}

#ifdef WARRIORS
extern s32 hal_timer_request(u32 interval_ms, void (* p_callback)(void), BOOL circular);
extern void hal_timer_start(u8 timer_id);
extern void hal_timer_stop(u8 timer_id);
extern void hal_timer_release(u8 timer_id);

#if 1
#define TS_PACKET_SIZE 188

// Given the PES packet data (i.e., the data starting 00 00 01 <stream_id>
// <packet_length>), decide if this PES packet is MPEG-1 (11172-1) or
// H.222.0 (13818-1)
#define IS_MPEG_PES(data)  ((data[6] & 0xC0) == 0x80)

typedef struct
{
  u8 sync_byte;
  u16 transport_error_indicator :1;
  u16 payload_unit_start_indicator :1;
  u16 transport_priority : 1;
  u16 PID :13;
  u8 transport_scrambling_control :2;
  u8 adaptation_field_control : 2;
  u8 continuity_counter : 4;
}mpeg_transport_packet;

typedef struct
{
  u8 adaptation_field_length;
  u8 discontinuity_indicator : 1;
  u8 random_access_indicator : 1;
  u8 elementary_stream_priority_indicator :1;
  u8 PCR_flag : 1;
  u8 OPCR_flag : 1;
  u8 splicing_point_flag :1;
  u8 transport_private_data_flag :1 ;
  u8 adaptation_field_extension_flag : 1;
}adaptation_field;

typedef struct
{
  u32 packet_start_code_prefix : 24;
  u32 stream_id : 8;
  u16 pes_packet_length;
}pes_packet;

/*
 * Split a TS packet into its main parts
 *
 * - `buf` is the data for the packet
 * - `pid` is the PID of said data
 * - `payload_unit_start_indicator` is TRUE if any payload in this
 *   packet forms the start of a PES packet. Its meaning is not significant
 *   if there is no payload, or if the payload is not (part of) a PES packet.
 * - `adapt` is an offset into `buf`, acting as an array of the actual
 *   adaptation control bytes. It will be NULL if there are no adaptation
 *   controls.
 * - `adapt_len` is the length of the adaptation controls (i.e., the
 *   number of bytes). It will be 0 if there are no adaptation controls.
 * - `payload` is an offset into `buf`, acting as an array of the actual
 *   payload bytes. It will be NULL if there is no payload.
 * - `payload_len` is the length of the payload *in this packet* (i.e., the
 *   number of bytes. It will be 0 if there is no payload.
 *
 * Returns 0 if all went well, 1 if something went wrong.
 */
u32 split_TS_packet(u8  buf[TS_PACKET_SIZE],
                           u16 *pid,
                           u8      *payload_unit_start_indicator,
                           u8     **adapt,
                           u8      *adapt_len,
                           u8     **payload,
                           u8      *payload_len)
{
  u32     adaptation_field_control;
  mpeg_transport_packet  *ts_packet_head = NULL;

  ts_packet_head = (mpeg_transport_packet *)buf;

  if (buf[0] != 0x47)
  {
    OS_PRINTF("### TS packet starts %02x, not %02x\n",buf[0],0x47);
    return 1;
  }
  *payload_unit_start_indicator = (buf[1] & 0x40) >> 6;
  *pid = ((buf[1] & 0x1f) << 8) | buf[2];

  if (*pid == 0x1FFF)
  {
    // Null packets don't contain any data, so let's not allow "spurious"
    // interpretation of their innards
    *adapt = NULL;
    *adapt_len = 0;
    *payload = NULL;
    *payload_len = 0;
    return 0;
  }

  adaptation_field_control = (buf[3] & 0x30) >> 4;
  switch (adaptation_field_control)
  {
  case 0:
    OS_PRINTF("### Packet PID %04x has adaptation field control = 0\n"
               "    which is a reserved value (no payload, no adaptation field)\n",
               *pid);
    *adapt = NULL;
    *adapt_len = 0;
    *payload = NULL;
    *payload_len = 0;
    break;
  case 1:
    // Payload only
    *adapt = NULL;
    *adapt_len = 0;
    *payload = buf + 4;
    *payload_len = TS_PACKET_SIZE - 4;
    break;
  case 2:
    // Adaptation field only
    *adapt_len = buf[4];
    if (*adapt_len == 0)
      *adapt = NULL;
    else
      *adapt = buf + 5;
    *payload = NULL;
    *payload_len = 0;
    break;
  case 3:
    // Payload and adaptation field
    *adapt_len = buf[4];
    if (*adapt_len == 0)
      *adapt = NULL;
    else
      *adapt = buf + 5;
      *payload = buf + 5 + buf[4];
      *payload_len = TS_PACKET_SIZE - 5 - buf[4];
    break;
  default:
    // How this might occur, other than via program error, I can't think.
    OS_PRINTF("### Packet PID %04x has adaptation field control %x\n",
               *pid,adaptation_field_control);
    return 1;
  }
  return 0;
}

static u32 get_next_ts_packet(u8 *p_addr,u32 *length)
{
  u32 p_buf;
  p_buf = (u32)p_addr + TS_PACKET_SIZE;
  (*length)++;
  return p_buf;
}

static void parse_av_ts_stream()
{
    u8 *p_addr;
    u32 length = 0;

    u16 pid;
    u8   payload_unit_start_indicator;
    u8   *adapt, *payload;
    u8   adapt_len, payload_len;
    BOOL    need_packet_start = TRUE;
    BOOL    got_pes_packet_len = FALSE;
    u32    pes_packet_len = 0;
    u8  *data = NULL;
    u32    data_len = 0;

    //pes_packet *pes_packet_head =NULL;

    p_addr = (u8 *)dmx_rec_buffer_address;

    while(p_addr[0]==0x47)
    {
      split_TS_packet(p_addr,&pid,&payload_unit_start_indicator,
                         &adapt,&adapt_len,&payload,&payload_len);

      // If the packet is empty, all we can do is ignore it
      if (payload_len == 0)
      {
          //p_addr += TS_PACKET_SIZE;
          OS_PRINTF("payload length is NULL\n");
          p_addr = (u8 *)get_next_ts_packet(p_addr,&length);
          continue;
      }

      if (payload_unit_start_indicator)
      {
        // It's the start of a PES packet, so we need to drop the header
        u32 offset;

        if (need_packet_start)
          need_packet_start = FALSE;

        pes_packet_len = (payload[4] << 8) | payload[5];

        OS_PRINTF("PES packet length %d adapt_len %d\n",pes_packet_len,adapt_len);
        got_pes_packet_len = (pes_packet_len > 0);

        if (IS_MPEG_PES(payload))
        {
          offset = payload[8] + 9;
        }
        else
        {
          OS_PRINTF("It's not Mpeg ts stream\n");
          p_addr = (u8 *)get_next_ts_packet(p_addr,&length);
          continue;
        }
        data = &payload[offset];
        data_len = payload_len-offset;
        OS_PRINTF(">>addr %x len %d \n",data,data_len);
      }
      else
      {
          // If we haven't *started* a packet, we can't use this,
          // since it will just look like random bytes when written out.
          if (need_packet_start)
          {
              p_addr = (u8 *)get_next_ts_packet(p_addr,&length);
              continue;
          }

          data = payload;
          data_len = payload_len;

          if (got_pes_packet_len)
          {
            // Try not to write more data than the PES packet declares
            if (data_len > pes_packet_len)
            {
                data_len = pes_packet_len;
                pes_packet_len = 0;
            }
            else
                pes_packet_len -= data_len;
          }
          OS_PRINTF(">>>>addr %x len %d\n",data,data_len);
      }

      //we can write the data&dataLen to es buffer

      p_addr = (u8 *)get_next_ts_packet(p_addr,&length);
    }
    OS_PRINTF("the tatal number %d packets!!!\n",length);

    TESTFM_SETRESULT(RET_SUCCESS, 0x2a, FALSE);
}
#endif

static BOOL play_is_underflow()
{
    u32 rec_circle_time = 0;
    u32 play_circle_time = 0;
    u32 real_rec_location = 0;
    u32 real_play_location = 0;

    real_play_location = play_location_size % rec_play_total_size;
    real_rec_location = rec_location_size % rec_play_total_size;
    rec_circle_time = (u32) rec_location_size / rec_play_total_size;
    play_circle_time = (u32) play_location_size / rec_play_total_size;

    if(play_circle_time > rec_circle_time)
      MT_ASSERT(0);

    if((play_circle_time == rec_circle_time) &&
      ((real_rec_location - real_play_location) <= 188 * 4 * 16))
    {
        //OS_PRINTF("w circle times %d r circle times %d w_p %d r_p %d\n",
        //   rec_circle_time, play_circle_time, real_rec_location ,real_play_location);
        return TRUE;
    }
    else
      return FALSE;
}

static BOOL play_is_overflow()
{
    u32 rec_circle_time = 0;
    u32 play_circle_time = 0;
    u32 real_rec_location = 0;
    u32 real_play_location = 0;

    real_play_location = play_location_size % rec_play_total_size;
    real_rec_location = rec_location_size % rec_play_total_size;
    rec_circle_time = (u32) rec_location_size / rec_play_total_size;
    play_circle_time = (u32) play_location_size / rec_play_total_size;

    if((rec_circle_time > play_circle_time) && (real_rec_location >= real_play_location))
    {
        //OS_PRINTF("w circle times %d r circle times %d w_p %d r_p %d\n",
        //   rec_circle_time, play_circle_time, real_rec_location ,real_play_location);
        return TRUE;
    }
    else
      return FALSE;

}

static void dmx_config_dma(u16 length, u16 ts_clk, u32 addr)
{
    BOOL state = FALSE;
    dmx_dma_config_t dma_config;

    dmx_device_t *p_dev    = NULL;
    p_dev = (dmx_device_t *)dev_find_identifier(NULL
            , DEV_IDT_TYPE, SYS_DEV_TYPE_PTI);
    MT_ASSERT(NULL != p_dev->p_base);

    dma_config.data_length = length;
    dma_config.mem_address = addr;
    dma_config.ts_clk = ts_clk;

    dmx_set_dma_config(p_dev, &dma_config);

    while(1)
    {
        state = dmx_get_dma_state(p_dev);
        //OS_PRINTF("dma wait!!!\n");
        if(state == TRUE)
          break;
    }
}

static void timer_dmx(void)
{
    BOOL overflow_flag = FALSE;
    BOOL underflow_flag = FALSE;
    u32 play_size = dmx_rec_buffer_unit * 20;
    u32 play_addr = 0;
    u32 os_tick = 0;
#ifdef __LINUX__    
    u8 *dma_buffer;
    u8 *playback_buffer;
    dmx_device_t *p_dev    = NULL;
    
    p_dev = (dmx_device_t *)dev_find_identifier(NULL
           , DEV_IDT_TYPE, SYS_DEV_TYPE_PTI);
    MT_ASSERT(NULL != p_dev->p_base);

    dmx_get_playback_buffer(p_dev, &dma_buffer);
    dmx_get_record_buffer(p_dev, &playback_buffer);
#endif

    if(rec_play_flag == TRUE)
    {
       os_tick = mtos_ticks_get();
       //OS_PRINTF("dma playing running...\n");
        overflow_flag = play_is_overflow();
        if( overflow_flag == TRUE)
          OS_PRINTF("Buf overflow:DMA Transform data to pti is slower!!!\n");

        while(1)
        {
            underflow_flag = play_is_underflow();
            if(underflow_flag == TRUE)
            {
               //OS_PRINTF("Buf underflow:DMA Transform data to pti is faster!!!\n");
               return;
            }
            else
              break;
       }

        play_addr = (u32)p_rec_play_buf + (play_location_size % rec_play_total_size);
        //OS_PRINTF("the dma play size %d\n",play_location_size);
        //OS_PRINTF("dma start addr %x len %d!!!\n",play_addr,play_size);
        #ifdef __LINUX__
         //memcpy(dma_buffer, playback_buffer, play_size);
         memcpy(dma_buffer, (u8*)play_addr, play_size);
         dmx_config_dma(play_size, rec_ts_clk,(u32)dma_buffer);
        // while(dmx_get_dma_state(p_dev) == FALSE);
       //  fwrite(dma_buffer, play_size, 1, record_file);
        #else
         dmx_config_dma(play_size/4, rec_ts_clk,(u32)play_addr);
        #endif
        play_location_size += play_size;
        //OS_PRINTF("the time cost %d\n",mtos_ticks_get() - os_tick);
   }
}

static void dmx_stream_input_select(u32 data)
{
    switch(data)
    {
        case 0:
          stream_input_port =  DMX_INPUT_EXTERN0;
          break;
        case 1:
          stream_input_port =  DMX_INPUT_EXTERN1;
          break;
        case 2:
          stream_input_port =  DMX_INPUT_EXTERN_CI;
          break;
        case 3:
          stream_input_port =  DMX_INPUT_EXTERN_DMA;
          break;
    }
    OS_PRINTF("DMX: set the stream input type [%d]\n",stream_input_port);

    TESTFM_SETRESULT(RET_SUCCESS, 0x2a, FALSE);
    return;
}

static void dmx_rec_channel_set(u32 *p_data,u32 length)
{
    u8 last_cc = 0;
    u8 cur_cc = 0;
    BOOL first_flag = TRUE;

    u32 times = dmx_timeout * 10000;
    u32 i = 0;
    u32 rec_size = 0;
    u32 rec_ts_read = 0;
    dmx_chanid_t chanid[128];
    RET_CODE ret;

    dmx_rec_setting_t rec_t;
    dmx_device_t *p_dev    = NULL;

    p_dev = (dmx_device_t *)dev_find_identifier(NULL
            , DEV_IDT_TYPE, SYS_DEV_TYPE_PTI);
    MT_ASSERT(NULL != p_dev->p_base);

    OS_PRINTF("rec pid total count is %d\n",length - 3);

    if(length - 3 > 128)
    {
        OS_PRINTF("record pid is too more,the max number is 128!!!\n");
        TESTFM_SETRESULT(RET_FAIL, 0x10, FALSE);
        return;
    }

    OS_PRINTF("rec port is %d\n",p_data[0]);
    OS_PRINTF("rec type is %d\n",p_data[1]);
    OS_PRINTF("rec buffer size is %d(unit:188*40)\n",p_data[2]);

    //1.open a slot for recording ts packet.
    OS_PRINTF("1.open a slot for recording ts packet.\n");
    if(p_data[1] == DMX_PARTIAL_TS_PACKET)
    {
        if(length <= 3)
        {
            OS_PRINTF("record parameter is too small!!!\n");
            TESTFM_SETRESULT(RET_FAIL, 0x10, FALSE);
            return;
        }
        for(i = 0; i < length - 3; i++)
        {
          OS_PRINTF("The %d pid is %d\n",i,p_data[i + 3]);
          rec_t.pid = p_data[i + 3];
          rec_t.rec_in = p_data[0];
          rec_t.stream_in = stream_input_port;
          rec_t.type_mode = DMX_PARTIAL_TS_PACKET;
          ret = dmx_rec_chan_open(p_dev,&rec_t,&chanid[i]);
          if(ret != SUCCESS)
          {
            OS_PRINTF("open rec channel failed!\n");
            TESTFM_SETRESULT(RET_FAIL, 0x10, FALSE);
            return;
          }
        }
    }
    else
    {
        if(length < 3)
        {
            OS_PRINTF("record parameter is too small!!!\n");
            TESTFM_SETRESULT(RET_FAIL, 0x10, FALSE);
            return;
        }
        rec_t.pid = 0;
        rec_t.rec_in = p_data[0];
        rec_t.stream_in = stream_input_port;
        rec_t.type_mode = p_data[1];
        ret = dmx_rec_chan_open(p_dev,&rec_t,&chanid[0]);
        if(ret != SUCCESS)
        {
          OS_PRINTF("open rec channel failed!\n");
          TESTFM_SETRESULT(RET_FAIL, 0x10, FALSE);
          return;
        }
    }

    //2.set buffer and size
    OS_PRINTF("2.set buffer and size\n");
    ret = dmx_rec_chan_set_buffer(p_dev,p_data[0],
                (u8 *)dmx_rec_buffer_address,dmx_rec_circle_range_unit *2* p_data[2]);
    if( ret != SUCCESS)
    {
        OS_PRINTF("set buffer failed!\n");
        TESTFM_SETRESULT(RET_FAIL, 0x10, FALSE);
        return;
    }

    //3.start the slot
    OS_PRINTF("3.start the slot\n");
    if(p_data[1] == DMX_PARTIAL_TS_PACKET)
    {
       for(i = 0;i < length - 3; i++)
        {
            ret = dmx_chan_start(p_dev,chanid[i]);
            if(ret != SUCCESS)
            {
                OS_PRINTF("start channel  failed!\n");
                TESTFM_SETRESULT(RET_FAIL, 0x10, FALSE);
                return;
            }
        }
    }
    else
    {
        ret = dmx_chan_start(p_dev,chanid[0]);
        if(ret != SUCCESS)
        {
            OS_PRINTF("start channel  failed!\n");
            TESTFM_SETRESULT(RET_FAIL, 0x10, FALSE);
            return;
        }
    }

    //4.get data
    OS_PRINTF("4.get data\n");
    while(1)
    {
        rec_size = 0;
        ret = dmx_rec_get_data(p_dev,p_data[0],&rec_size);
        if(ret != SUCCESS)
        {
            OS_PRINTF("get data failed!!!\n");
            TESTFM_SETRESULT(RET_FAIL, 0x10, FALSE);
            return;
        }

        if( rec_size == 0) //no data
        {
          OS_PRINTF(".");
          if((--times)<=0)
            break;
        }
        else
        {
            times = dmx_timeout * 100;

            rec_ts_read += rec_size;

            if(p_data[2] == 0)
            {
                if(rec_ts_read >= 3 * 1024 * 1024)
                  break;
            }
            else
            {
              if(rec_ts_read >= dmx_rec_circle_range_unit * p_data[2])
                  break;
            }
        }

        mtos_task_delay_ms(1);
		#ifdef __LINUX__
        usleep(5000);
		#endif
    }

    //5.close the rec slot
    OS_PRINTF("5.close the rec slot\n");

    if(p_data[1] == DMX_PARTIAL_TS_PACKET)
    {
        for(i = 0;i < length - 3; i++)
        {
            ret=dmx_chan_stop(p_dev, chanid[i]);
            MT_ASSERT(ret==SUCCESS);

            ret=dmx_chan_close(p_dev, chanid[i]);
            MT_ASSERT(ret==SUCCESS);
        }
    }
    else
    {
        ret=dmx_chan_stop(p_dev, chanid[0]);
        MT_ASSERT(ret==SUCCESS);

        ret=dmx_chan_close(p_dev, chanid[0]);
        MT_ASSERT(ret==SUCCESS);
    }

    if(times == 0)
    {
        OS_PRINTF("time out!!!\n");
        TESTFM_SETRESULT(RET_FAIL, 0x10, FALSE);
        return;
    }

    if(p_data[2] == 0)
    {
        OS_PRINTF("record finished!!!\n");
    }
    else
    {
        for(i = 0 ;i < (dmx_rec_circle_range_unit * p_data[2]) / 188; i++)
        {
            OS_PRINTF("[%d] addr[0x%08x] 0x%02x 0x%02x 0x%02x 0x%02x\n",i,
                                dmx_rec_buffer_address+i*188,
                                *(u8 *)(dmx_rec_buffer_address+i*188),
                                *(u8 *)(dmx_rec_buffer_address+i*188+1),
                                *(u8 *)(dmx_rec_buffer_address+i*188+2),
                                *(u8 *)(dmx_rec_buffer_address+i*188+3));

            if((p_data[1] == DMX_PARTIAL_TS_PACKET) && (length == 4)) //only one partial pid
            {
                    cur_cc = (*(u8 *)(dmx_rec_buffer_address+i*188+3))&0x0f;
                    if(first_flag == TRUE)
                    {
                        last_cc = cur_cc;
                        first_flag = FALSE;
                    }
                    else
                    {
                        if(((last_cc + 1)%16) == cur_cc)
                        {
                            last_cc = cur_cc;
                            continue;
                        }
                        else
                        {
                            OS_PRINTF("cc is not correct [%d] packets!\n",i);
                            TESTFM_SETRESULT(RET_FAIL, 0x10, FALSE);
                            return;
                        }
                     }
            }
        }

        if((p_data[1] == DMX_PARTIAL_TS_PACKET) && (length == 4)) //only one partial pid
        {
          OS_PRINTF("rec data is OK!total [%d] packets!!!\n",i);
        }
    }

    TESTFM_SETRESULT(RET_SUCCESS, 0x2a, FALSE);
    return;
}

static void dmx_play_rec_content_test(u32 vpid,u32 apid,u32 pcrpid,u32 ts_clk,u32 len)
{
    RET_CODE ret;
    u32 times = dmx_timeout * 10000;
    u32 rec_size = 0;
    dmx_rec_setting_t rec_t;
    dmx_device_t *p_dev    = NULL;
    s32 timer = 0;
    
	#ifdef __LINUX__
    FILE * record_file;
    record_file = fopen("/mnt/record.ts", "wb"); 
    #endif

    p_dev = (dmx_device_t *)dev_find_identifier(NULL
            , DEV_IDT_TYPE, SYS_DEV_TYPE_PTI);
    MT_ASSERT(NULL != p_dev->p_base);

    rec_ts_clk = ts_clk;
    timer = hal_timer_request(2, timer_dmx, TRUE);
    MT_ASSERT(timer >= 0);
    hal_timer_start(timer);
    OS_PRINTF("dmx timer create,set the ts clk %x len(M) %d !!!\n",rec_ts_clk,len);

    //*(volatile u32 *)(0xbfef071c) = 0x22800000;
    //*(volatile u32 *)(0xbfef0720) = 0x6800000;
    //*(volatile u32 *)(0xbfef0728) = 0xffffffff;

    //1.first rec special pid, the size is out of 5M
    if(vpid != 0x1fff)
    {
        rec_t.pid = vpid;
        rec_t.rec_in = DMX_REC_CONFIG0;
        rec_t.stream_in = stream_input_port;
        rec_t.type_mode = DMX_PARTIAL_TS_PACKET;
        ret = dmx_rec_chan_open(p_dev,&rec_t,&rec_video_chan);
        if(ret != SUCCESS)
        {
          OS_PRINTF("Don't open video channel!\n");
          TESTFM_SETRESULT(RET_FAIL, 0x10, FALSE);
          return;
        }
    }
    if(apid != 0x1fff)
    {
        rec_t.pid = apid;
        rec_t.rec_in = DMX_REC_CONFIG0;
        rec_t.stream_in = stream_input_port;
        rec_t.type_mode = DMX_PARTIAL_TS_PACKET;
        ret = dmx_rec_chan_open(p_dev,&rec_t,&rec_audio_chan);
        if(ret != SUCCESS)
        {
          OS_PRINTF("Don't open audio channel!\n");
          TESTFM_SETRESULT(RET_FAIL, 0x10, FALSE);
          return;
        }
    }
    if((pcrpid != 0x1fff) && (pcrpid != vpid))
    {
        rec_t.pid = pcrpid;
        rec_t.rec_in = DMX_REC_CONFIG0;
        rec_t.stream_in = stream_input_port;
        rec_t.type_mode = DMX_PARTIAL_TS_PACKET;
        ret = dmx_rec_chan_open(p_dev,&rec_t,&rec_pcr_chan);
        if(ret != SUCCESS)
        {
          OS_PRINTF("Don't open pcr channel!\n");
          TESTFM_SETRESULT(RET_FAIL, 0x10, FALSE);
          return;
        }
    }

    rec_threshold_size = dmx_rec_buffer_unit * 20 * 2;
    #ifdef __LINUX__
    rec_play_total_size = dmx_rec_circle_range_unit * 60;
    #else
    rec_play_total_size = dmx_rec_circle_range_unit * 96;    // The value max is 188 * 4 * 127
    #endif
    p_rec_play_buf = (u8*)dmx_rec_buffer_address;
    // memory total 64M,record start in physical addr 44M

    ret = dmx_rec_chan_set_buffer(p_dev,DMX_REC_CONFIG0,p_rec_play_buf,rec_play_total_size);
    if( ret != SUCCESS)
    {
        OS_PRINTF("set buffer failed!\n");
        TESTFM_SETRESULT(RET_FAIL, 0x10, FALSE);
        return;
    }

    if(vpid != 0x1fff)
    {
        ret = dmx_chan_start(p_dev,rec_video_chan);
        if(ret != SUCCESS)
        {
            OS_PRINTF("start video channel  failed!\n");
            TESTFM_SETRESULT(RET_FAIL, 0x10, FALSE);
            return;
        }
    }
    if(apid != 0x1fff)
    {
        ret = dmx_chan_start(p_dev,rec_audio_chan);
        if(ret != SUCCESS)
        {
            OS_PRINTF("start video channel  failed!\n");
            TESTFM_SETRESULT(RET_FAIL, 0x10, FALSE);
            return;
        }
    }
    if((pcrpid != 0x1fff) && (pcrpid != vpid))
    {
        ret = dmx_chan_start(p_dev,rec_pcr_chan);
        if(ret != SUCCESS)
        {
            OS_PRINTF("start video channel  failed!\n");
            TESTFM_SETRESULT(RET_FAIL, 0x10, FALSE);
            return;
        }
    }

    while(1)
    {
        rec_size = 0;
        //OS_PRINTF("rec get data\n");
        ret = dmx_rec_get_data(p_dev,DMX_REC_CONFIG0,&rec_size);
        if(ret != SUCCESS)
        {
            OS_PRINTF("get data failed!!!\n");
            TESTFM_SETRESULT(RET_FAIL, 0x10, FALSE);
            return;
        }

        if( rec_size == 0) //no data
        {
          //OS_PRINTF(".");
          if((times--)<=0)
          {
            OS_PRINTF("no stream input!timeout!!!\n");
            break;
          }
        }
        else
        {
            times = dmx_timeout * 10000;
            rec_location_size = rec_size;
            
            if((rec_play_flag == FALSE)&&(rec_location_size + 188 >= rec_threshold_size))
            {
                rec_play_flag = TRUE;
                //set the channel play
                #ifndef __LINUX__
                *(volatile u32 *)(0xbfef01fc) = 0x7ff8e000 + vpid;
                *(volatile u32 *)(0xbfef01f8) = 0x7ff9e000 + apid;
                *(volatile u32 *)(0xbfef01f4) = 0x7ffae000 + pcrpid;
                #else
                {
                    dmx_play_setting_t play_para;   

                    printf("open play channel......\n");
                    if(apid != 0x1fff)  
                    {
                        play_para.pid = apid;
                        play_para.type = DMX_AUDIO_TYPE;
                        play_para.stream_in = DMX_INPUT_EXTERN_DMA;
                        ret=dmx_play_chan_open(p_dev,&play_para,&audio_chan); // 690
                        MT_ASSERT(ret == SUCCESS);
                    }
                    
                    if(vpid != 0x1fff)
                    {
                        play_para.pid = vpid;
                        play_para.type = DMX_VIDEO_TYPE;
                        play_para.stream_in = DMX_INPUT_EXTERN_DMA;
                        ret=dmx_play_chan_open(p_dev,&play_para,&video_chan); // 516
                        MT_ASSERT(ret == SUCCESS);
                    }
                    
                    if(pcrpid != 0x1fff)
                    {
                        play_para.pid = pcrpid;
                        play_para.type = DMX_PCR_TYPE;
                        play_para.stream_in = DMX_INPUT_EXTERN_DMA;
                        ret=dmx_play_chan_open(p_dev,&play_para,&pcr_chan);
                        MT_ASSERT(ret == SUCCESS);
                    }
                    
                    if(video_chan != 0xffff)
                    {
                        ret=dmx_chan_start(p_dev,video_chan); 
                        MT_ASSERT(ret == SUCCESS);
                    }

                    if(audio_chan != 0xffff)
                    {
                        ret=dmx_chan_start(p_dev,audio_chan); 
                        MT_ASSERT(ret == SUCCESS);
                    }

                    if(pcr_chan != 0xffff)
                    {  
                        ret=dmx_chan_start(p_dev,pcr_chan); 
                        MT_ASSERT(ret == SUCCESS);  
                    }
                }
                #endif
            }

            if(rec_location_size >= len * 1024 * 1024)
            {
              OS_PRINTF("rec data is over %d M!!!\n",len);
              break;
            }
        }
    }

    if(vpid != 0x1fff)
    {
        ret=dmx_chan_stop(p_dev, rec_video_chan);
        MT_ASSERT(ret==SUCCESS);

        ret=dmx_chan_close(p_dev, rec_video_chan);
        MT_ASSERT(ret==SUCCESS);
    }
    if(apid != 0x1fff)
    {
        ret=dmx_chan_stop(p_dev, rec_audio_chan);
        MT_ASSERT(ret==SUCCESS);

        ret=dmx_chan_close(p_dev, rec_audio_chan);
        MT_ASSERT(ret==SUCCESS);
    }
    if((pcrpid != 0x1fff) && (pcrpid != vpid))
    {
        ret=dmx_chan_stop(p_dev, rec_pcr_chan);
        MT_ASSERT(ret==SUCCESS);

        ret=dmx_chan_close(p_dev, rec_pcr_chan);
        MT_ASSERT(ret==SUCCESS);
    }

    OS_PRINTF("close the channel!!!\n");

    rec_play_flag = FALSE;
    p_rec_play_buf = NULL;
    rec_play_total_size = 0;

    rec_threshold_size = 0;
    rec_location_size = 0;
    play_location_size = 0;

    #ifdef __LINUX__
    dmx_stop_play();
	fclose(record_file);
    #endif

    
    hal_timer_stop(timer);
    hal_timer_release(timer);

    OS_PRINTF("dmx timer release!!!\n");

    TESTFM_SETRESULT(RET_SUCCESS, 0x2a, FALSE);
}

extern RET_CODE dmx_warriors_network_play_stop(void *p_dmx);
extern RET_CODE dmx_warriors_network_play_start(void *p_dmx,
                                                    dmx_network_play_setting_t *p_network);
static void dmx_rec_network_test(u32 vpid,u32 apid,u32 pcrpid,u32 ts_clk,u32 len)
{
#ifndef __LINUX__
    RET_CODE ret;
    u32 times = dmx_timeout * 1000000;
    u32 rec_size = 0;
    dmx_device_t *p_dev    = NULL;
    u8 pid_count = 0;
    u16 pid_grp[10];
    dmx_network_play_setting_t network_play;
    s32 timer = 0;

    p_dev = (dmx_device_t *)dev_find_identifier(NULL
            , DEV_IDT_TYPE, SYS_DEV_TYPE_PTI);
    MT_ASSERT(NULL != p_dev->p_base);

    rec_threshold_size = dmx_rec_buffer_unit * 20 * 2;
    rec_play_total_size = dmx_rec_circle_range_unit * 96;    // The value max is 188 * 4 * 127
    p_rec_play_buf = (u8*)dmx_rec_buffer_address;

    rec_ts_clk = ts_clk;
    timer = hal_timer_request(2, timer_dmx, TRUE);
    MT_ASSERT(timer >= 0);
    hal_timer_start(timer);
    OS_PRINTF("dmx timer create,set the ts clk %x len(M) %d !!!\n",rec_ts_clk,len);

    //1.first rec special pid, the size is out of 5M
    if(vpid != 0x1fff)
    {
        pid_grp[0] = vpid;
        pid_count++;
    }

    if(apid != 0x1fff)
    {
        pid_grp[1] = apid;
        pid_count++;
    }

    if((pcrpid != 0x1fff) && (pcrpid != vpid))
    {
        pid_grp[2] = pcrpid;
        pid_count++;
    }

    network_play.p_pid = pid_grp;
    network_play.pid_count = pid_count;
    network_play.p_buf = p_rec_play_buf;
    network_play.size = rec_play_total_size;
    network_play.stream_in = DMX_INPUT_EXTERN0;

    ret = dmx_warriors_network_play_start(p_dev,&network_play);
    MT_ASSERT(ret==SUCCESS);
    // memory total 64M,record start in physical addr 40M
    while(1)
    {
        rec_size = 0;
        //OS_PRINTF("rec get data\n");
        ret = dmx_rec_get_data(p_dev,DMX_REC_CONFIG1,&rec_size);
        if(ret != SUCCESS)
        {
            OS_PRINTF("get data failed!!!\n");
            TESTFM_SETRESULT(RET_FAIL, 0x10, FALSE);
            return;
        }

        if( rec_size == 0) //no data
        {
          //OS_PRINTF(".");
          if((times--)<=0)
          {
            OS_PRINTF("no stream input!timeout!!!\n");
            break;
          }
        }
        else
        {
            times = dmx_timeout * 1000000;
            rec_location_size += rec_size;

            if((rec_play_flag == FALSE)&&(rec_location_size + 188 >= rec_threshold_size))
            {
                rec_play_flag = TRUE;
                //set the channel play
                *(volatile u32 *)(0xbfef01fc) = 0x7ff8e000 + vpid;
                *(volatile u32 *)(0xbfef01f8) = 0x7ff9e000 + apid;
                *(volatile u32 *)(0xbfef01f4) = 0x7ffae000 + pcrpid;
            }

            if(rec_location_size >= len * 1024 * 1024)
            {
              OS_PRINTF("rec data is over %d M!!!\n",len);
              break;
            }
        }
    }

    dmx_warriors_network_play_stop(p_dev);

    OS_PRINTF("close the network play!!!\n");

    rec_play_flag = FALSE;
    p_rec_play_buf = NULL;
    rec_play_total_size = 0;

    rec_threshold_size = 0;
    rec_location_size = 0;
    play_location_size = 0;

    hal_timer_stop(timer);
    hal_timer_release(timer);

    OS_PRINTF("dmx timer release!!!\n");

    TESTFM_SETRESULT(RET_SUCCESS, 0x2a, FALSE);

#endif
}

void dmx_dma_one_frame(u8 *p_src, u32 size,u16 ts_clk,u16 vpid)
{
    u32 i = 0;
    dmx_device_t* p_dev    = NULL;
    RET_CODE ret;
    dmx_play_setting_t play_para;
    dmx_chanid_t video_chan;
    u32 time0 = 0;
	#ifdef __LINUX__
    u8 *frame_buffer;
	#endif

    p_dev = (dmx_device_t *)dev_find_identifier(NULL
            , DEV_IDT_TYPE, SYS_DEV_TYPE_PTI);
    MT_ASSERT(NULL != p_dev->p_base);
    
	#ifdef __LINUX__
    dmx_get_playback_buffer(p_dev, &frame_buffer);
    memcpy(frame_buffer, p_src, size);
	#endif

    play_para.pid = vpid;
    play_para.type = DMX_VIDEO_TYPE;
    play_para.stream_in = DMX_INPUT_EXTERN_DMA;
    ret=dmx_play_chan_open(p_dev,&play_para,&video_chan);
    MT_ASSERT(ret == SUCCESS);

    ret=dmx_chan_start(p_dev,video_chan);
    MT_ASSERT(ret == SUCCESS);

    #ifdef __LINUX__
    dmx_config_dma(size/4, ts_clk,(u32)frame_buffer);

    //mtos_task_delay_ms(10);    //make sure the dma send the data over.
    while(dmx_get_dma_state(p_dev) == FALSE);
	#else
    for(i = 0; i < 10; i++)
    {
        time0 = mtos_ticks_get();
        dmx_config_dma(size, ts_clk,(u32)p_src);
        {
              {
                OS_PRINTF("dma send %d\n",mtos_ticks_get() - time0);
              }
        }
    }
	#endif
    mtos_task_delay_ms(10);    //make sure the dma send the data over.

    ret=dmx_chan_stop(p_dev,video_chan);
    MT_ASSERT(ret == SUCCESS);
    ret=dmx_chan_close(p_dev,video_chan);
    MT_ASSERT(ret == SUCCESS);

    TESTFM_SETRESULT(RET_SUCCESS, 0x2a, FALSE);
}

static void dmx_ufs_test(u32 *p_data,u32 length)
{
    dmx_rec_setting_t rec_t;
    dmx_device_t *p_dev    = NULL;
    dmx_chanid_t chanid[128];
    RET_CODE ret;

    u32 i = 0;
    u32 rec_size = 0;
    u32 real_size = 0;
    vfs_t *p_vfs = NULL;
    #ifdef __LINUX__
    FILE * p_file;
    #else
    hfile_t p_file = {0};
    #endif

    u32 read_pt =0;
    u8  *rec_buffer = 0;
    u8  *ddr_buffer = 0;
    u32 rec_buffer_size = 0;
    u32 rec_total_size = 0;
    u32 cur_size = 0;

    p_dev = (dmx_device_t *)dev_find_identifier(NULL
            , DEV_IDT_TYPE, SYS_DEV_TYPE_PTI);
    MT_ASSERT(NULL != p_dev->p_base);
    p_vfs = class_get_handle_by_id(VFS_CLASS_ID);

    drv_dev_t *p_gUsb_dev = NULL;
    p_gUsb_dev = (drv_dev_t *)dev_find_identifier
      (NULL, DEV_IDT_NAME, (u32)DEV_NAME_BLOCK_USB1);


    OS_PRINTF("rec pid total count is %d\n",length - 3);

    if(length - 4 > 128)
    {
        OS_PRINTF("record pid is too more,the max number is 128!!!\n");
        TESTFM_SETRESULT(RET_FAIL, 0x10, FALSE);
        return;
    }

    OS_PRINTF("rec port is %d\n",p_data[0]);
    OS_PRINTF("rec type is %d\n",p_data[1]);
    OS_PRINTF("rec buffer size is %d(unit:188*40)\n",p_data[2]);
    OS_PRINTF("rec total size %d (Unit:M)",p_data[3]);

    //1.open a slot for recording ts packet.
    OS_PRINTF("1.open a slot for recording ts packet.\n");
    if(p_data[1] == DMX_PARTIAL_TS_PACKET)
    {
        if(length <= 3)
        {
            OS_PRINTF("record parameter is too small!!!\n");
            TESTFM_SETRESULT(RET_FAIL, 0x10, FALSE);
            return;
        }
        for(i = 0; i < length - 4; i++)
        {
          OS_PRINTF("The %d pid is %d\n",i,p_data[i + 4]);
          rec_t.pid = p_data[i + 4];
          rec_t.rec_in = p_data[0];
          rec_t.stream_in = stream_input_port;
          rec_t.type_mode = DMX_PARTIAL_TS_PACKET;
          ret = dmx_rec_chan_open(p_dev,&rec_t,&chanid[i]);
          if(ret != SUCCESS)
          {
            OS_PRINTF("open rec channel failed!\n");
            TESTFM_SETRESULT(RET_FAIL, 0x10, FALSE);
            return;
          }
        }
    }
    else
    {
        if(length < 4)
        {
            OS_PRINTF("record parameter is too small!!!\n");
            TESTFM_SETRESULT(RET_FAIL, 0x10, FALSE);
            return;
        }
        rec_t.pid = 0;
        rec_t.rec_in = p_data[0];
        rec_t.stream_in = stream_input_port;
        rec_t.type_mode = p_data[1];
        ret = dmx_rec_chan_open(p_dev,&rec_t,&chanid[0]);
        if(ret != SUCCESS)
        {
          OS_PRINTF("open rec channel failed!\n");
          TESTFM_SETRESULT(RET_FAIL, 0x10, FALSE);
          return;
        }
    }

    //2.set buffer and size
    #ifdef __LINUX__
    rec_buffer = dmx_rec_buffer_address;
    #else
    rec_buffer = (u8 *)mtos_nc_malloc(dmx_rec_circle_range_unit * p_data[2]);
    #endif
    ddr_buffer = (u8 *)mtos_nc_malloc(dmx_rec_circle_range_unit * p_data[2]);
    MT_ASSERT(rec_buffer != NULL);
    MT_ASSERT(ddr_buffer != NULL);

    rec_buffer_size = dmx_rec_circle_range_unit * p_data[2];
    #ifdef __LINUX__
    if(rec_buffer_size > 512 * 1024)
     {
        OS_PRINTF("record buffer is too large!\n");
        return;
    }
    #endif
    ret = dmx_rec_chan_set_buffer(p_dev,p_data[0],rec_buffer,rec_buffer_size);
    if( ret != SUCCESS)
    {
        OS_PRINTF("set buffer failed!\n");
        TESTFM_SETRESULT(RET_FAIL, 0x10, FALSE);
        return;
    }
    OS_PRINTF("2.set buffer %x and size %d\n",rec_buffer,rec_buffer_size);

 //   vfs_mount(0);
    #ifdef __LINUX__
    p_file = fopen("/mnt/record.ts", "wb"); 
    #else
    p_file = p_vfs->open((u8 *)("C:\\wr.ts"), VFS_NEW);
    #endif
    OS_PRINTF("open first file ok!\n");
    //3.start the slot
    OS_PRINTF("3.start the slot\n");
    if(p_data[1] == DMX_PARTIAL_TS_PACKET)
    {
       for(i = 0;i < length - 4; i++)
        {
            ret = dmx_chan_start(p_dev,chanid[i]);
            if(ret != SUCCESS)
            {
                OS_PRINTF("start channel  failed!\n");
                TESTFM_SETRESULT(RET_FAIL, 0x10, FALSE);
                return;
            }
        }
    }
    else
    {
        ret = dmx_chan_start(p_dev,chanid[0]);
        if(ret != SUCCESS)
        {
            OS_PRINTF("start channel  failed!\n");
            TESTFM_SETRESULT(RET_FAIL, 0x10, FALSE);
            return;
        }
    }

    while(1)
    {
      ret = dmx_rec_get_data(p_dev,p_data[0],&rec_size);
      if( rec_size == 0) //no data
      {
        //OS_PRINTF(".");
      }
      else
      {
           cur_size = rec_size - rec_total_size;
          if(read_pt + cur_size > rec_buffer_size)
          {
            OS_PRINTF("2.%d bytes!\n",cur_size);
            
			#ifdef __LINUX__
            if(cur_size <= rec_buffer_size) {
               real_size = fwrite(rec_buffer+read_pt, rec_buffer_size-read_pt, 1, p_file);
               real_size +=  fwrite(rec_buffer, cur_size - (rec_buffer_size -read_pt), 1, p_file);
           #else
             memcpy(ddr_buffer,rec_buffer+read_pt, rec_buffer_size-read_pt);
             memcpy(ddr_buffer + rec_buffer_size-read_pt
                ,rec_buffer, cur_size - (rec_buffer_size -read_pt));

            //real_size = p_vfs->write(p_file, rec_buffer+read_pt, rec_buffer_size-read_pt);
            //MT_ASSERT(real_size == (rec_buffer_size-read_pt));
            //real_size = p_vfs->write(p_file, rec_buffer, rec_size - (rec_buffer_size -read_pt));
           //MT_ASSERT(real_size == (rec_size - (rec_buffer_size -read_pt)));

            real_size = p_vfs->write(p_file, ddr_buffer, cur_size);
            #endif
            
             if(real_size != cur_size)
             {
                OS_PRINTF("real size %d write size %d\n",real_size,cur_size);
                MT_ASSERT(real_size == cur_size);
             }
            read_pt = cur_size - (rec_buffer_size-read_pt);
			#ifdef __LINUX__
            }
			#endif
          }
          else
          {
            OS_PRINTF("1.%d bytes!\n",cur_size); 
            #ifdef __LINUX__
             // printf("1 s\n");
             // fwrite(ddr_buffer, 1, cur_size, p_file);
              fwrite(rec_buffer + read_pt, cur_size, 1, p_file);
             // printf("1 e\n");
            #else
                memcpy(ddr_buffer,rec_buffer + read_pt, cur_size);
               real_size = p_vfs->write(p_file, ddr_buffer, cur_size);
            #endif
              MT_ASSERT(real_size == cur_size);
              read_pt += cur_size;
          }
       rec_total_size = rec_size;
      }

      if(rec_total_size >= p_data[3] * 1024 *1024)
       break;
    }
    OS_PRINTF("\n");
    #ifdef __LINUX__
    fclose(p_file);
    #else
    p_vfs->close(p_file);
    #endif
    
    //5.close the rec slot
    OS_PRINTF("5.close the rec slot\n");

    if(p_data[1] == DMX_PARTIAL_TS_PACKET)
    {
        for(i = 0;i < length - 4; i++)
        {
            ret=dmx_chan_stop(p_dev, chanid[i]);
            MT_ASSERT(ret==SUCCESS);

            ret=dmx_chan_close(p_dev, chanid[i]);
            MT_ASSERT(ret==SUCCESS);
        }
    }
    else
    {
        ret=dmx_chan_stop(p_dev, chanid[0]);
        MT_ASSERT(ret==SUCCESS);

        ret=dmx_chan_close(p_dev, chanid[0]);
        MT_ASSERT(ret==SUCCESS);
    }
    TESTFM_SETRESULT(RET_SUCCESS, 0x2a, FALSE);
}

#ifndef __LINUX__
static void dmx_ddr_file_test(u32 vpid,u32 apid,u32 pcrpid,u32 ts_clk)
    {
  dmx_device_t *p_dev    = NULL;
  void *p_vdec_dev = NULL;
  //RET_CODE ret;
  u16 last = 1000;
  dmx_dma_config_t dma_config;
  BOOL state = FALSE;
  u8 *p_addr = NULL;
  u8 *p_addr0 = NULL;
  u8 *p_addr1 = NULL;
  u8 *p_addr2 = NULL;
  BOOL w_flag = TRUE;
  BOOL wait_flag = FALSE;
  u32 read_len = 0;

  u32 buf_size = 1200 * 188;
  vfs_t *p_vfs = NULL;
  hfile_t p_file = {0};
  u32 read_size = 0;

  OS_PRINTF("file play test case\n");

  p_dev = (dmx_device_t *)dev_find_identifier(NULL
          , DEV_IDT_TYPE, SYS_DEV_TYPE_PTI);
  MT_ASSERT(NULL != p_dev->p_base);
  p_vfs = class_get_handle_by_id(VFS_CLASS_ID);

  p_vdec_dev = dev_find_identifier(NULL, DEV_IDT_TYPE, SYS_DEV_TYPE_VDEC_VSB);
  MT_ASSERT(NULL != p_vdec_dev);

  //dmx_start_play(160, 80, 160);
  *(volatile u32 *)(0xbfef01fc) = 0x7ff8e000 + vpid;
  *(volatile u32 *)(0xbfef01f8) = 0x7ff9e000 + apid;
  *(volatile u32 *)(0xbfef01f4) = 0x7ffae000 + pcrpid;

  //vdec_set_data_input(p_vdec_dev, TRUE);

  //ret = vdec_start(p_vdec_dev, 0, 0);
  //MT_ASSERT(SUCCESS == ret);

  //p_addr = (u8 *)mtos_malloc(buf_size);
  //MT_ASSERT(p_addr != NULL);
  p_addr0 = (u8 *)dmx_rec_buffer_address;
  p_addr1 = (u8 *)(dmx_rec_buffer_address + 0x100000);
  p_addr2 = (u8 *)(0xac800000);

  //p_file = p_vfs->open((u8 *)("C:\\HNSTV.ts"), VFS_READ);

  //read_size = p_vfs->read(p_file, p_addr0, buf_size);
  memcpy(p_addr0,p_addr2 + read_len,buf_size);
  read_len += buf_size;
  //config addr
  if(read_len >=  30 * 1024 * 1024)
  {
    OS_PRINTF("read end of file\n");
    TESTFM_SETRESULT(RET_FAIL, 0x10, FALSE);
    return;
  }
  p_addr = p_addr0;

  while(1)
  {
    u32 time0 = mtos_ticks_get();

    //read file
    dma_config.data_length = buf_size;
    dma_config.mem_address = (u32)p_addr;
    dma_config.ts_clk = 323000000  / ts_clk * 8;
    //OS_PRINTF("config dma addr 0x%x size %d\n",(u32)p_addr,read_size/4);
    dmx_set_dma_config(p_dev, &dma_config);
    //OS_PRINTF("addr %x!\n",p_addr);

  //MPEG_PAT* pMpegPAT;
  //TSD*    pTSD;

    //TS_GetSession(TSD_CTRL_PLAYBACK, &pTSD);

    //TS_PBCK_SetEnabled(TRUE);
  //get PAT
  //result = TS_MPEG_PatGet(pTSD, &pMpegPAT, 1000);
  //printf("TS_MPEG_PatGet - retVal = %d\n", result);
    //MT_ASSERT(result == TRUE);
    //OS_PRINTF("num pro 0x%x\n",pMpegPAT->numPrograms);
    while(1)
    {
      //mtos_task_delay_ms(100);
      if(wait_flag == FALSE)
      {
        if(w_flag == TRUE)
        {
            //OS_PRINTF("<");

          //read_size = p_vfs->read(p_file, p_addr1, buf_size);
          memcpy(p_addr1,p_addr2 + read_len,buf_size);
          read_len += buf_size;
            //OS_PRINTF(">");

          //config addr

            if(read_len >=  30 * 1024 * 1024)
          {
            OS_PRINTF("read end of file\n");
            break;
          }
          p_addr = p_addr1;
          w_flag = FALSE;
          //OS_PRINTF("read addr %d %x!\n",mtos_ticks_get(),p_addr1);
        }
        else
        {
               //OS_PRINTF("(");

          //read_size = p_vfs->read(p_file, p_addr0, buf_size);
          memcpy(p_addr0,p_addr2 + read_len,buf_size);
          read_len += buf_size;
               //OS_PRINTF(")");

          //config addr
            if(read_len >=  30 * 1024 * 1024)
          {
            OS_PRINTF("read end of file\n");
            break;
          }
          p_addr = p_addr0;
          w_flag = TRUE;
         // OS_PRINTF("read addr %d %x!\n",mtos_ticks_get(),p_addr0);
        }

        //OS_PRINTF("(");

        wait_flag = TRUE;
        //OS_PRINTF("read file %d\n",mtos_ticks_get() - time0);
      }

     //OS_PRINTF("!");

      state = dmx_get_dma_state(p_dev);
      if(state == TRUE)
      {
        //OS_PRINTF("dma send %d\n",mtos_ticks_get() - time0);
        break;
      }
    }
            if(read_len >=  30 * 1024 * 1024)
      break;
    wait_flag = FALSE;
 //   OS_PRINTF(".");
  }
    OS_PRINTF("\n");
    OS_PRINTF("waiting...\n");
  //p_vfs->close(p_file);

  TESTFM_SETRESULT(RET_SUCCESS, 0x2a, FALSE);
}
#endif
static void dmx_file_test(u32 vpid,u32 apid,u32 pcrpid,u32 ts_clk)
{
#ifndef __LINUX__
  dmx_device_t *p_dev    = NULL;
  void *p_vdec_dev = NULL;
  //RET_CODE ret;
  u16 last = 1000;
  dmx_dma_config_t dma_config;
  BOOL state = FALSE;
  u8 *p_addr = NULL;
  u8 *p_addr0 = NULL;
  u8 *p_addr1 = NULL;
  BOOL w_flag = TRUE;
  BOOL wait_flag = FALSE;

  u32 buf_size = 1200 * 188;
  vfs_t *p_vfs = NULL;
  hfile_t p_file = {0};
  u32 read_size = 0;

  OS_PRINTF("file play test case\n");

  p_dev = (dmx_device_t *)dev_find_identifier(NULL
          , DEV_IDT_TYPE, SYS_DEV_TYPE_PTI);
  MT_ASSERT(NULL != p_dev->p_base);
  p_vfs = class_get_handle_by_id(VFS_CLASS_ID);

  p_vdec_dev = dev_find_identifier(NULL, DEV_IDT_TYPE, SYS_DEV_TYPE_VDEC_VSB);
  MT_ASSERT(NULL != p_vdec_dev);

  //dmx_start_play(160, 80, 160);
  *(volatile u32 *)(0xbfef01fc) = 0x7ff8e000 + vpid;
  *(volatile u32 *)(0xbfef01f8) = 0x7ff9e000 + apid;
  *(volatile u32 *)(0xbfef01f4) = 0x7ffae000 + pcrpid;

  //vdec_set_data_input(p_vdec_dev, TRUE);

  //ret = vdec_start(p_vdec_dev, 0, 0);
  //MT_ASSERT(SUCCESS == ret);

  //p_addr = (u8 *)mtos_malloc(buf_size);
  //MT_ASSERT(p_addr != NULL);
  p_addr0 = (u8 *)dmx_rec_buffer_address;
  p_addr1 = (u8 *)(dmx_rec_buffer_address + 0x100000);

  p_file = p_vfs->open((u8 *)("C:\\HNSTV.ts"), VFS_READ);

  read_size = p_vfs->read(p_file, p_addr0, buf_size);
  //config addr
  if(read_size == 0)
  {
    OS_PRINTF("read end of file\n");
    return;
  }
  p_addr = p_addr0;

  while(1)
  {
    u32 time0 = mtos_ticks_get();

    //read file
    dma_config.data_length = read_size;
    dma_config.mem_address = (u32)p_addr;
    dma_config.ts_clk = 81000000 * 8 / ts_clk;
    //OS_PRINTF("config dma addr 0x%x size %d\n",(u32)p_addr,read_size/4);
    dmx_set_dma_config(p_dev, &dma_config);
    //OS_PRINTF("addr %x!\n",p_addr);

  //MPEG_PAT* pMpegPAT;
  //TSD*    pTSD;

    //TS_GetSession(TSD_CTRL_PLAYBACK, &pTSD);

    //TS_PBCK_SetEnabled(TRUE);
  //get PAT
  //result = TS_MPEG_PatGet(pTSD, &pMpegPAT, 1000);
  //printf("TS_MPEG_PatGet - retVal = %d\n", result);
    //MT_ASSERT(result == TRUE);
    //OS_PRINTF("num pro 0x%x\n",pMpegPAT->numPrograms);
    while(1)
    {
      //mtos_task_delay_ms(100);
      if(wait_flag == FALSE)
      {
        if(w_flag == TRUE)
        {
            //OS_PRINTF("<");

          read_size = p_vfs->read(p_file, p_addr1, buf_size);
            //OS_PRINTF(">");

          //config addr

          if(read_size == 0)
          {
            OS_PRINTF("read end of file\n");
            break;
          }
          p_addr = p_addr1;
          w_flag = FALSE;
          //OS_PRINTF("read addr %d %x!\n",mtos_ticks_get(),p_addr1);
        }
        else
        {
               //OS_PRINTF("(");

          read_size = p_vfs->read(p_file, p_addr0, buf_size);
               //OS_PRINTF(")");

          //config addr
          if(read_size == 0)
          {
            OS_PRINTF("read end of file\n");
            break;
          }
          p_addr = p_addr0;
          w_flag = TRUE;
         // OS_PRINTF("read addr %d %x!\n",mtos_ticks_get(),p_addr0);
        }

        //OS_PRINTF("(");

        wait_flag = TRUE;
        //OS_PRINTF("read file %d\n",mtos_ticks_get() - time0);
      }

     //OS_PRINTF("!");

      state = dmx_get_dma_state(p_dev);
      if(state == TRUE)
      {
        //OS_PRINTF("dma send %d\n",mtos_ticks_get() - time0);
        break;
      }
    }
    if(read_size == 0)
      break;
    wait_flag = FALSE;
 //   OS_PRINTF(".");
  }
    OS_PRINTF("\n");
    OS_PRINTF("waiting...\n");
  p_vfs->close(p_file);
#else
    dmx_device_t* p_dev    = NULL;
    RET_CODE ret;
    dmx_play_setting_t play_para;     
    dmx_dma_config_t dma_config;    
    u8 *test_stream_data;
    int size;
    
    int fd = open("/mnt/test.ts", O_RDWR);
    if(fd < 0)
      perror("open test.ts:");

    OS_PRINTF("bababalabalabalabala\n");
    p_dev = (dmx_device_t *)dev_find_identifier(NULL
            , DEV_IDT_TYPE, SYS_DEV_TYPE_PTI);
    MT_ASSERT(NULL != p_dev->p_base);

  printf("%ld %ld %ld %ld\n", vpid, apid, pcrpid, ts_clk);
  // 1. set play slot and start them
    if(apid != 0x1fff)  
    {
        play_para.pid = apid;
        play_para.type = DMX_AUDIO_TYPE;
        play_para.stream_in = DMX_INPUT_EXTERN_DMA;
        ret=dmx_play_chan_open(p_dev,&play_para,&audio_chan); // 690
        MT_ASSERT(ret == SUCCESS);
    }

    if(vpid != 0x1fff)
    {
        play_para.pid = vpid;
        play_para.type = DMX_VIDEO_TYPE;
        play_para.stream_in = DMX_INPUT_EXTERN_DMA;
        ret=dmx_play_chan_open(p_dev,&play_para,&video_chan); // 516
        MT_ASSERT(ret == SUCCESS);
    }

    if(pcrpid != 0x1fff)
    {
        play_para.pid = pcrpid;
        play_para.type = DMX_PCR_TYPE;
        play_para.stream_in = DMX_INPUT_EXTERN_DMA;
        ret=dmx_play_chan_open(p_dev,&play_para,&pcr_chan);
        MT_ASSERT(ret == SUCCESS);
    }

    if(video_chan != 0xffff)
    {
        ret=dmx_chan_start(p_dev,video_chan); 
        MT_ASSERT(ret == SUCCESS);
    }

    if(audio_chan != 0xffff)
    {
        ret=dmx_chan_start(p_dev,audio_chan); 
        MT_ASSERT(ret == SUCCESS);
    }

    if(pcr_chan != 0xffff)
    {  
        ret=dmx_chan_start(p_dev,pcr_chan); 
        MT_ASSERT(ret == SUCCESS);  
    }

    // 2. start send data to dma of dmx
    
     dmx_get_playback_buffer(p_dev, &test_stream_data);
     
     while(1)
     {
         lseek(fd, 0, SEEK_SET);
         printf("buffer addr %p\n", test_stream_data);
         while((size = read(fd, test_stream_data, 300*188)) != 0)
         {     
             dma_config.data_length = size;
             dma_config.mem_address = (u32)test_stream_data;
             dma_config.ts_clk = 323000000  / ts_clk * 8;/*81000000 * 8 / ts_clk*/;
             dmx_set_dma_config(p_dev, &dma_config);
             while(dmx_get_dma_state(p_dev) == FALSE);
         }
         printf("finished\n");
         break;
     }
     
     close(fd);
#endif
}

#endif

#ifdef ORCHID
static void dmx_rec_test()
{
    dmx_rec_setting_t rec_t;
    dmx_device_t *p_dev    = NULL;
    u8 last = 100;
    dmx_chanid_t rec_chan1 = 0xffff;
    dmx_chanid_t rec_chan2 = 0xffff;
    dmx_chanid_t rec_chan3 = 0xffff;
    dmx_chanid_t rec_chan4 = 0xffff;
    RET_CODE ret;
    OS_LINEAR_BUFF_ST BuffInfo;
    u32 rec_size = 0;
    u32 rec_total_length = 0;
    vfs_t *p_vfs = NULL;
    hfile_t p_file = {0};
    u32 last_read_pt = 0;
    u32 read_pt =0;

    p_dev = (dmx_device_t *)dev_find_identifier(NULL
            , DEV_IDT_TYPE, SYS_DEV_TYPE_PTI);
    MT_ASSERT(NULL != p_dev->p_base);
    p_vfs = class_get_handle_by_id(VFS_CLASS_ID);

 /*   rec_t.pid = 0;//pat
    rec_t.rec_in = DMX_REC_CONFIG0;
    rec_t.stream_in = stream_input_port;
    rec_t.type_mode = DMX_FULL_TS_WITH_NULL_PACKET;
    ret = dmx_rec_chan_open(p_dev,&rec_t,&rec_chan1);
    if(ret != SUCCESS)
    {
      OS_PRINTF("open rec channel failed!\n");
      return;
    }

    rec_t.pid = 0x190;//pmt
    rec_t.rec_in = DMX_REC_CONFIG0;
    rec_t.stream_in = stream_input_port;
    rec_t.type_mode = DMX_FULL_TS_WITH_NULL_PACKET;
    ret = dmx_rec_chan_open(p_dev,&rec_t,&rec_chan2);
    if(ret != SUCCESS)
    {
      OS_PRINTF("open rec channel failed!\n");
      return;
    }
    */
    rec_t.pid = 517;//video
    rec_t.rec_in = DMX_REC_CONFIG0;
    rec_t.stream_in = stream_input_port;
    rec_t.type_mode = DMX_FULL_TS_WITH_NULL_PACKET;
    ret = dmx_rec_chan_open(p_dev,&rec_t,&rec_chan3);
    if(ret != SUCCESS)
    {
      OS_PRINTF("open rec channel failed!\n");
      return;
    }

    rec_t.pid = 700;//audio
    rec_t.rec_in = DMX_REC_CONFIG0;
    rec_t.stream_in = stream_input_port;
    rec_t.type_mode = DMX_FULL_TS_WITH_NULL_PACKET;
    ret = dmx_rec_chan_open(p_dev,&rec_t,&rec_chan4);
    if(ret != SUCCESS)
    {
      OS_PRINTF("open rec channel failed!\n");
      return;
    }

    rec_t.pid = 8190;//pcr
    rec_t.rec_in = DMX_REC_CONFIG0;
    rec_t.stream_in = stream_input_port;
    rec_t.type_mode = DMX_FULL_TS_WITH_NULL_PACKET;
    ret = dmx_rec_chan_open(p_dev,&rec_t,&rec_chan2);
    if(ret != SUCCESS)
    {
      OS_PRINTF("open rec channel failed!\n");
      return;
    }

    ret = OS_LinearBuffAllocate(&BuffInfo,2560*188*5);
    MT_ASSERT(TRUE == ret);

    ret = dmx_rec_chan_set_buffer(p_dev,DMX_REC_CONFIG0,BuffInfo.address,BuffInfo.size);
    if( ret != SUCCESS)
    {
        OS_PRINTF("set buffer failed!\n");
        return FALSE;
    }

 //   vfs_mount(0);
    p_file = p_vfs->open("C:\\wr.ts", VFS_NEW);

 //   dmx_chan_start(p_dev,rec_chan1);
    dmx_chan_start(p_dev,rec_chan2);
    dmx_chan_start(p_dev,rec_chan3);
    dmx_chan_start(p_dev,rec_chan4);

    while(last)
    {
      dmx_rec_get_data(p_dev,DMX_REC_CONFIG0,&rec_size);
      if( rec_size == 0) //no data
      {
        OS_PRINTF(".");
      }
      else
      {
          OS_PRINTF("rece %d bytes,total %d bytes!\n",rec_size,rec_total_length);
          if(read_pt +rec_size - rec_total_length >BuffInfo.size)
          {
            p_vfs->write(p_file, BuffInfo.address+read_pt, BuffInfo.size-read_pt);
            p_vfs->write(p_file, BuffInfo.address,
              rec_size - rec_total_length - (BuffInfo.size-read_pt));
            read_pt =rec_size - rec_total_length - (BuffInfo.size-read_pt);
          }
          else
          {
            p_vfs->write(p_file, BuffInfo.address+read_pt, rec_size - rec_total_length);
            read_pt += rec_size - rec_total_length;
          }
          rec_total_length = rec_size;
      }

      mtos_task_delay_ms(1000);

      last --;
      OS_PRINTF(".");
    }
    OS_PRINTF("\n");
    p_vfs->close(&p_file);

//    ret=dmx_chan_stop(p_dev, rec_chan1);
//    MT_ASSERT(ret == SUCCESS);
    ret=dmx_chan_stop(p_dev, rec_chan2);
    MT_ASSERT(ret == SUCCESS);
    ret=dmx_chan_stop(p_dev, rec_chan3);
    MT_ASSERT(ret == SUCCESS);
    ret=dmx_chan_stop(p_dev, rec_chan4);
    MT_ASSERT(ret == SUCCESS);

 //   ret=dmx_chan_close(p_dev, rec_chan1);
  //  MT_ASSERT(ret == SUCCESS);
    ret=dmx_chan_close(p_dev, rec_chan2);
    MT_ASSERT(ret == SUCCESS);
    ret=dmx_chan_close(p_dev, rec_chan3);
    MT_ASSERT(ret == SUCCESS);
    ret=dmx_chan_close(p_dev, rec_chan4);
    MT_ASSERT(ret == SUCCESS);
}

static dmx_file_test()
{
  dmx_device_t *p_dev    = NULL;
  void *p_vdec_dev = NULL;
  RET_CODE ret;
  u16 last = 1000;
  dmx_dma_config_t dma_config;
  BOOL state = FALSE;
  u8 *p_addr = NULL;
  ACT_MODE actMode = {0};
  ERR_CODE  result = OK;
  OS_LINEAR_BUFF_ST buffInfo = {0};
  OS_LINEAR_BUFF_ST buffInfo1 = {0};
  u32 buf_size = 1024*188;
  vfs_t *p_vfs = NULL;
  hfile_t p_file = {0};
  u32 read_size = 0;

  OS_PRINTF("file play test case\n");

  p_dev = (dmx_device_t *)dev_find_identifier(NULL
          , DEV_IDT_TYPE, SYS_DEV_TYPE_PTI);
  MT_ASSERT(NULL != p_dev->p_base);
  p_vfs = class_get_handle_by_id(VFS_CLASS_ID);

  p_vdec_dev = dev_find_identifier(NULL, DEV_IDT_TYPE, SYS_DEV_TYPE_VDEC_VSB);
  MT_ASSERT(NULL != p_vdec_dev);

  dmx_start_play(0x191, 0x191, 0x191);

  vdec_set_data_input(p_vdec_dev, TRUE);

  ret = vdec_start(p_vdec_dev, 0, 0);
  MT_ASSERT(SUCCESS == ret);


  p_file = p_vfs->open("C:\\wr.ts", VFS_READ);


  result = OS_LinearBuffAllocate(&buffInfo, buf_size);
  MT_ASSERT(result == TRUE);
  result = OS_LinearBuffAllocate(&buffInfo1, buf_size);
  MT_ASSERT(result == TRUE);
  read_size =1;
  while(1)
  {
    // feed data
    last --;

    //read file

    //config addr

    if(p_addr == buffInfo.address)
    {
      p_addr =buffInfo1.address;
    }
    else
    {
      p_addr =buffInfo.address;
    }
    read_size = p_vfs->read(p_file, p_addr, buf_size);
    if(read_size == 0)
    {
      OS_PRINTF("read end of file\n");
      break;
    }
    dma_config.data_length = buf_size;
    dma_config.mem_address = (u32)p_addr;
    dma_config.ts_clk = 5000;
    OS_PRINTF("config dma addr 0x%x\n",(u32)p_addr);
    dmx_set_dma_config(p_dev, &dma_config);

  //MPEG_PAT* pMpegPAT;
  //TSD*    pTSD;

    //TS_GetSession(TSD_CTRL_PLAYBACK, &pTSD);

    //TS_PBCK_SetEnabled(TRUE);
  //get PAT
  //result = TS_MPEG_PatGet(pTSD, &pMpegPAT, 1000);
  //printf("TS_MPEG_PatGet - retVal = %d\n", result);
    //MT_ASSERT(result == TRUE);
    //OS_PRINTF("num pro 0x%x\n",pMpegPAT->numPrograms);
    while(1)
    {
      mtos_task_delay_ms(100);
      state = dmx_get_dma_state(p_dev);
      OS_PRINTF(".\n");
     // OS_PRINTF("dma wait!!!\n");
      if(state == TRUE)
        break;
    }
 //   OS_PRINTF(".");
  }
    OS_PRINTF("\n");
    OS_PRINTF("waiting...\n");
      mtos_task_delay_ms(10000);
  dmx_stop_play();
  vdec_stop(p_vdec_dev);
  p_vfs->close(p_file);
}

static void dmx_pes_test(u16 pid, u16 pcr_pid, u8 type)
{
  TSD *p_session;
  PESDevice *PesDevice;
  u8 *ret_buf;
  u32 buf_size = 1024*500;
  ERR_CODE ret = 0;
  u32 pes_type = FV_PARSE_PES_OTHER;


  if(pid == 0 || pcr_pid == 0)
  {
    OS_PRINTF("pid error pid %d  pcr %d\n",pid,pcr_pid);
      return;
  }

  switch(type)
  {
    case 0:
      pes_type = FV_PARSE_PES_VIDEO;
      break;
    case 1:
      pes_type = FV_PARSE_PES_AUDIO;
      break;
    case 2:
      pes_type = FV_PARSE_PES_OTHER;
      break;
    default :
      pes_type = FV_PARSE_PES_OTHER;
      break;
  }
  TS_GetSession(TSD_CTRL_INPUT_DEMOD_0, &p_session);

  ret = TS_DMX_PesDeviceActivate(
  p_session,
  pid,
  pcr_pid,
  pes_type,
  buf_size,
  &ret_buf,
  &PesDevice);

  MT_ASSERT(ret == OK);


  TS_DMX_PesDeviceStart(PesDevice);
  ret = FAIL;
  while(ret != OK)
  {
    OS_PRINTF(".");
    ret = WaitForPES(PesDevice, 10);
  }

  if(ret == OK)
  {
    OS_PRINTF("data received\n");
    if(pes_type != FV_PARSE_PES_OTHER)
    {
      u8 *curAddressp = ret_buf;
      u8 *returnErrorPointer =NULL;
      u32 returnSTC = 0;
      u32 returnSTCDelta = 0;
      u32 returnPts = 0;
      u32 returnDts = 0;
      u32 returnArrivalTs;
      u32 returnValidData = 0;
      u32 returnBufferBytes = 0;
      PESHeader *returnPESHeader = NULL;
      u32 returnNumStamps =0;
      u32 returnFlags = 0;
      u8 *returnGOPArray = NULL;
      u32 returnGOPArraySize = 0;
      u32 returnGOPIndex = 0;
      u32 i = 0;


      ret = GetTLPESHeader(PesDevice,     // The Pes monitor
           0,     // See comments above
           0,   // PESFLAGS
           &curAddressp,    // The address that the client is at now
           &returnErrorPointer, // Location of first error, if any
           &returnSTC,    // The current System Time Clock comparable with PTS and DTS
           &returnSTCDelta, // The delta that can be added to subsequent calls to Demux_GetSTC
           &returnPts,    // The PTS (if any)
           &returnDts,    // The DTS (if any)
           &returnArrivalTs,  // Time the PTS/DTS was received
           &returnValidData,  // The amount of data client should consume
           &returnBufferBytes,  // The number of bytes in the buffer
           &returnPESHeader, // PES Header structure
           &returnNumStamps,      // Number of Time Stamps currently received
           &returnFlags,
           &returnGOPArray,     // array containing frame types for the current and previous GOP (for smooth rewind)
           &returnGOPArraySize, // size of returnGOPArray
           &returnGOPIndex  // index of current frame info in returnGOPArray
          );
      //MT_ASSERT(ret == OK);
      OS_PRINTF("data size return %d ret %d\n",returnBufferBytes, ret);
      PrintPESHeader(returnPESHeader);
    }
    else
    {
      UINT8   returnStreamId;   // The stream id of the PES Packet
      UINT8*    returnErrorPointer; // Location of first error, if any
      UINT32    returnSTC;      // The current System Time Clock comparable with PTS and DTS
      UINT32    returnSTCDelta;   // The delta that can be added to subsequent calls to Demux_GetSTC
      BOOL8   returnPtsPresent; // Whether a PTS is available
      BOOL8   returnDtsPresent;   // Whether a DTS is available
      UINT32    returnPts;      // The PTS (if any)
      UINT32    returnDts;      // The DTS (if any)
      UINT32    returnArrivalTs;  // Time the PTS/DTS was received
      UINT32    returnValidData;
      u8 *p_pes = NULL;
      u32 i = 0;
      ret = TS_DMX_PesGetIndependentPacketPointers(
      PesDevice,        // The Pes monitor
      &returnStreamId,    // The stream id of the PES Packet
      &returnErrorPointer, // Location of first error, if any
      &returnSTC,     // The current System Time Clock comparable with PTS and DTS
      &returnSTCDelta,    // The delta that can be added to subsequent calls to Demux_GetSTC
      &returnPtsPresent,  // Whether a PTS is available
      &returnDtsPresent,  // Whether a DTS is available
      &returnPts,     // The PTS (if any)
      &returnDts,     // The DTS (if any)
      &returnArrivalTs, // Time the PTS/DTS was received
      &returnValidData);
      //MT_ASSERT(ret == OK);
      OS_PRINTF("data size return %d  stream_id 0x%x ret %d\n",
      returnValidData, returnStreamId, ret);

      p_pes = mtos_malloc(returnValidData);
      MT_ASSERT(p_pes != NULL);
      ret = TS_DMX_PesGetIndependentData(PesDevice, p_pes,returnValidData);
      MT_ASSERT(ret == OK);
      for(i = 0; i< 20; i ++)
      {
        OS_PRINTF("0x%x ",p_pes[i]);
      }
      OS_PRINTF("\n");
      mtos_free(p_pes);
      OS_PRINTF("pts %d dts %d stc %d \n",
      returnPts, returnDts, returnSTC);
    }
  }
  TS_DMX_PesDeviceStop(PesDevice, 0);
  TS_DMX_PesDeviceDeactivate(PesDevice);
}

#endif

static RET_CODE dmx_eit_set(dmx_para_list *p_list)
{
    RET_CODE dmx_ret = ERR_FAILURE;

    dmx_slot_setting_t slot_t;
    dmx_filter_setting_t  filter_param_t;
    dmx_device_t* p_dev    = NULL;

    p_dev = (dmx_device_t *)dev_find_identifier(NULL
            , DEV_IDT_TYPE, SYS_DEV_TYPE_PTI);
    MT_ASSERT(NULL != p_dev->p_base);

    slot_t.in     =stream_input_port;
    slot_t.pid   =p_list->pid;
    slot_t.type = p_list->dmx_ch_type;
    dmx_ret=dmx_si_chan_open(p_dev,&slot_t,&p_list->dmx_chanid);
    if(dmx_ret!=SUCCESS)
    {
      OS_PRINTF("open si channel failed!\n");
      return ERR_FAILURE;
    }

    //list[j].buf =(u8*)(((u32)dmx_memory_malloc(list[j].buf_size) +7) & (0xfffffff8));
    p_list->buf = dmx_memory_malloc(p_list->buf_size);

    OS_PRINTF("buf address 0x%08x\n",p_list->buf);
    dmx_ret= dmx_si_chan_set_buffer(p_dev,p_list->dmx_chanid,p_list->buf,p_list->buf_size);
    if(dmx_ret!=SUCCESS)
    {
      OS_PRINTF("set filter buffer failed!\n");
      return ERR_FAILURE;
    }

    filter_param_t.continuous = TRUE;
    filter_param_t.en_crc = TRUE;
    memset(filter_param_t.value,0x00,DMX_SECTION_FILTER_SIZE);
    memset(filter_param_t.mask,0x00,DMX_SECTION_FILTER_SIZE);

    filter_param_t.value[0]=p_list->table_id;
    filter_param_t.mask[0]=0xff;
    dmx_ret = dmx_si_chan_set_filter(p_dev,p_list->dmx_chanid,&filter_param_t);
    if(dmx_ret!=SUCCESS)
    {
      OS_PRINTF("set filter failed!\n");
      return ERR_FAILURE;
    }

    p_list->length = 0;
    dmx_ret = dmx_chan_start(p_dev,p_list->dmx_chanid);
    if(dmx_ret != SUCCESS)
    {
      OS_PRINTF("start channel  failed!\n");
      return ERR_FAILURE;
    }

    return SUCCESS;
}

static void dmx_eit_test_cmd(u32 data)
{
    os_msg_t  msg        = {0};

    if(data == TRUE)
    { 
        msg.content  = DMX_EIT_TEST_START;
        mtos_messageq_send(dmx_cmd_msg_handle, &msg);
    }
    else
    {
        msg.content  = DMX_EIT_TEST_STOP;
        mtos_messageq_send(dmx_cmd_msg_handle, &msg);
    }
 
    TESTFM_SETRESULT(RET_SUCCESS, 0x2a, FALSE);
}

static void dmx_eit_rece_data()
{
    u32 i,j;
    u16 count = 0;
    RET_CODE ret;
    dmx_device_t* p_dev    = NULL;
    u8* p_data;
    u32 size;

    p_dev = (dmx_device_t *)dev_find_identifier(NULL
          , DEV_IDT_TYPE, SYS_DEV_TYPE_PTI);
    MT_ASSERT(NULL != p_dev->p_base);
    
    count = sizeof(list) / sizeof(dmx_para_list);

    for(j=0;j<count;j++)
    {
        //if((j == 2) || (j == 3))
        //   continue;
        ret=dmx_si_chan_get_data(p_dev, list[j].dmx_chanid, &p_data, &size);
        if(ret != ERR_NO_RSRC )
        {
          if(ret == ERR_STATUS)
            OS_PRINTF("Get crc error data:addr [0x%08x] len[%d]!!!\n",p_data,size);

          list[j].length += size;

          OS_PRINTF("[%d]chanid %d pid 0x%02x Table[%08x] len[%d]:",
                         list[j].length,j,list[j].pid,p_data,size);
          for(i=0;i<5;i++)
            OS_PRINTF("%02x ",p_data[i]);
          OS_PRINTF("\n");       
        }
    }
}

static void dmx_eit_test_stop()
{
    u32 j = 0;
    u16 count = 0;
    RET_CODE ret;

    dmx_device_t* p_dev    = NULL;
    p_dev = (dmx_device_t *)dev_find_identifier(NULL
          , DEV_IDT_TYPE, SYS_DEV_TYPE_PTI);
    MT_ASSERT(NULL != p_dev->p_base);    

    count = sizeof(list) / sizeof(dmx_para_list);

    for(j=0;j<count;j++)
    {
        ret=dmx_chan_stop(p_dev, list[j].dmx_chanid);
        MT_ASSERT(ret == SUCCESS);

        ret=dmx_chan_close(p_dev, list[j].dmx_chanid);
        MT_ASSERT(ret == SUCCESS);

        dmx_memory_free(list[j].buf);
        list[j].buf = NULL;
    }
}

static void dmx_eit_test_start()
{
  BOOL circle_mode = FALSE;
  u32 j = 0;
  u16 count = 0;
  RET_CODE dmx_ret = ERR_FAILURE;

  dmx_device_t* p_dev    = NULL;

  p_dev = (dmx_device_t *)dev_find_identifier(NULL
          , DEV_IDT_TYPE, SYS_DEV_TYPE_PTI);
  MT_ASSERT(NULL != p_dev->p_base);

  count = sizeof(list) / sizeof(dmx_para_list);
  OS_PRINTF("Set the %d PID!!!\n",count);

  circle_mode = TRUE;
  for(j = 0;j< count; j++)
  {
     dmx_ret = dmx_eit_set(&list[j]);
     if(dmx_ret != SUCCESS)
      {
        return;
      }
  }
}

static void dmx_start_play(u32 vpid,u32 apid, u32 pcrpid)
{
  dmx_device_t* p_dev    = NULL;
  RET_CODE ret;
  dmx_play_setting_t play_para;

  p_dev = (dmx_device_t *)dev_find_identifier(NULL
          , DEV_IDT_TYPE, SYS_DEV_TYPE_PTI);
  MT_ASSERT(NULL != p_dev->p_base);

  if(apid != 0x1fff)
  {
      play_para.pid = apid;
      play_para.type = DMX_AUDIO_TYPE;
      play_para.stream_in = DMX_INPUT_EXTERN0;
      ret=dmx_play_chan_open(p_dev,&play_para,&audio_chan); // 690
      MT_ASSERT(ret == SUCCESS);
  }

  if(vpid != 0x1fff)
  {
      play_para.pid = vpid;
      play_para.type = DMX_VIDEO_TYPE;
      play_para.stream_in = DMX_INPUT_EXTERN0;
      ret=dmx_play_chan_open(p_dev,&play_para,&video_chan); // 516
      MT_ASSERT(ret == SUCCESS);
  }

  if(pcrpid != 0x1fff)
  {
      play_para.pid = pcrpid;
      play_para.type = DMX_PCR_TYPE;
      play_para.stream_in = DMX_INPUT_EXTERN0;
      ret=dmx_play_chan_open(p_dev,&play_para,&pcr_chan);
      MT_ASSERT(ret == SUCCESS);
  }

  if(video_chan != 0xffff)
  {
      ret=dmx_chan_start(p_dev,video_chan);
      MT_ASSERT(ret == SUCCESS);
  }

  if(audio_chan != 0xffff)
  {
      ret=dmx_chan_start(p_dev,audio_chan);
      MT_ASSERT(ret == SUCCESS);
  }

  if(pcr_chan != 0xffff)
  {
      ret=dmx_chan_start(p_dev,pcr_chan);
      MT_ASSERT(ret == SUCCESS);
  }

  TESTFM_SETRESULT(RET_SUCCESS, 0x2a, FALSE);
}

static void dmx_stop_play()
{
  dmx_device_t* p_dev    = NULL;
  RET_CODE ret;

    p_dev = (dmx_device_t *)dev_find_identifier(NULL
            , DEV_IDT_TYPE, SYS_DEV_TYPE_PTI);
    MT_ASSERT(NULL != p_dev->p_base);

  if(audio_chan != 0xffff)
  {
      ret=dmx_chan_stop(p_dev,audio_chan);
      MT_ASSERT(ret == SUCCESS);
      ret=dmx_chan_close(p_dev,audio_chan);
      MT_ASSERT(ret == SUCCESS);
  }

  if(video_chan != 0xffff)
  {
      ret=dmx_chan_stop(p_dev,video_chan);
      MT_ASSERT(ret == SUCCESS);
      ret=dmx_chan_close(p_dev,video_chan);
      MT_ASSERT(ret == SUCCESS);
  }

  if(pcr_chan != 0xffff)
  {
      ret=dmx_chan_stop(p_dev,pcr_chan);
      MT_ASSERT(ret == SUCCESS);
      ret=dmx_chan_close(p_dev,pcr_chan);
      MT_ASSERT(ret == SUCCESS);
  }

  #ifndef __LINUX__
  dmx_av_reset(p_dev);
  #endif
  
  audio_chan = 0xffff;
  video_chan = 0xffff;
  pcr_chan = 0xffff;

  TESTFM_SETRESULT(RET_SUCCESS, 0x2a, FALSE);
}

BOOL video_flag = FALSE;
BOOL audio_flag = FALSE;

static void dmx_desc_close()
{
      dmx_device_t* p_dev    = NULL;
      RET_CODE ret;
      
      p_dev = (dmx_device_t *)dev_find_identifier(NULL
              , DEV_IDT_TYPE, SYS_DEV_TYPE_PTI);
      MT_ASSERT(NULL != p_dev->p_base);

      if(video_chan != 0xffff)
      {
          if(video_flag == TRUE)
          {
                ret = dmx_descrambler_onoff(p_dev,video_chan,FALSE);
                MT_ASSERT(ret==SUCCESS);
          }
          video_flag = FALSE;
      }
      else
        OS_PRINTF("No video prpgram playing now!!!\n");

      if (audio_chan != 0xffff)
      {
          if(audio_flag == TRUE)
          {
                ret = dmx_descrambler_onoff(p_dev,audio_chan,FALSE);
                MT_ASSERT(ret==SUCCESS);
          }

          audio_flag = FALSE;
      }
      else
        OS_PRINTF("No audio prpgram playing now!!!\n");
}

static void dmx_desc_set_key(u8 *even_key, u8 *odd_key)
{
      dmx_device_t* p_dev    = NULL;
      RET_CODE ret;
      
      p_dev = (dmx_device_t *)dev_find_identifier(NULL
              , DEV_IDT_TYPE, SYS_DEV_TYPE_PTI);
      MT_ASSERT(NULL != p_dev->p_base);

      if(video_chan != 0xffff)
      {
          if(video_flag == TRUE)
          {
                ret = dmx_descrambler_onoff(p_dev,video_chan,FALSE);
                MT_ASSERT(ret==SUCCESS);
          }
          
          ret = dmx_descrambler_onoff(p_dev,video_chan,TRUE);
          MT_ASSERT(ret==SUCCESS);

          ret = dmx_descrambler_set_odd_keys(p_dev,video_chan,odd_key,8);
          MT_ASSERT(ret == SUCCESS);
          ret = dmx_descrambler_set_even_keys(p_dev,video_chan,even_key,8);
          MT_ASSERT(ret == SUCCESS);

          video_flag = TRUE;
      }
      else
        OS_PRINTF("No video prpgram playing now!!!\n");

      if (audio_chan != 0xffff)
      {
          if(audio_flag == TRUE)
          {
                ret = dmx_descrambler_onoff(p_dev,audio_chan,FALSE);
                MT_ASSERT(ret==SUCCESS);
          }
          
          ret = dmx_descrambler_onoff(p_dev,audio_chan,TRUE);
          MT_ASSERT(ret == SUCCESS);

          ret = dmx_descrambler_set_odd_keys(p_dev,audio_chan,odd_key,8);
          MT_ASSERT(ret == SUCCESS);

          ret = dmx_descrambler_set_even_keys(p_dev,audio_chan,even_key,8);
          MT_ASSERT(ret == SUCCESS);

          audio_flag = TRUE;
      }
      else
        OS_PRINTF("No audio prpgram playing now!!!\n");
}

static void dmx_desc_test_cmd(u32 data)
{
    os_msg_t  msg        = {0};

    if(data == TRUE)
    { 
        msg.content  = DMX_DESC_TEST_START;
        mtos_messageq_send(dmx_cmd_msg_handle, &msg);
    }
    else
    {
        msg.content  = DMX_DESC_TEST_STOP;
        mtos_messageq_send(dmx_cmd_msg_handle, &msg);
    }
 
    TESTFM_SETRESULT(RET_SUCCESS, 0x2a, FALSE);
}

#define dmx_buf_size 188*512
//u8 dmx_buffer[dmx_buf_size];

#ifndef WARRIORS
static RET_CODE next_ts_packet_vsb(u8 **p_data,u32 *p_size,u32 rd_pointer, u8 *p_buf)
{
    #ifndef JAZZ
#ifndef  WARRIORS
    p_buf = (u8 *)(((u32)p_buf) | 0x10000000);
#else
    p_buf = (u8 *)(((u32)p_buf) | 0xa0000000);
#endif

    //OS_PRINTF("read p %d\n",rd_pointer);
    if(*(p_buf + rd_pointer) != 0x47)
      return ERR_NO_RSRC;

    *p_data = p_buf + rd_pointer;
    *p_size = 188;
    #else
    if(*(p_buf + rd_pointer + 4) != 0x47)
    {
      return ERR_NO_RSRC;
    }
    
    *p_data = p_buf + rd_pointer + 4;
    *p_size = 188;
    #endif
    return SUCCESS;
}
#endif

#ifdef JAZZ
static  u8   start_stop_flag = 0;
static void dmx_protect(u32 v_pid,u32 a_pid, u32 pcr_pid)
{
  u32 times = dmx_timeout2 * 3 * 1000;
  u32 i = 0;
  dmx_device_t* p_dev    = NULL;
  u32 dmx_cur_tick =  0;

  p_dev = (dmx_device_t *)dev_find_identifier(NULL
          , DEV_IDT_TYPE, SYS_DEV_TYPE_PTI);
  MT_ASSERT(NULL != p_dev->p_base);

  dmx_start_play(v_pid, a_pid, pcr_pid);

  while((--times) > 0)
    {
      dmx_cur_tick =  mtos_ticks_get();
      if(dmx_cur_tick > 1000)
        {
           i = dmx_cur_tick / 1000;
           dmx_cur_tick = dmx_cur_tick - (1000 * i );
        }
      OS_PRINTF("ticks  %d \n",dmx_cur_tick);
      if(dmx_cur_tick == 999)
        {
           OS_PRINTF("--------------stop filter  \n");
           if(start_stop_flag == 0)
            {
               dmx_stop_play();
              // dmx_last_tick = dmx_cur_tick;
               start_stop_flag = 1;
            }
           if(start_stop_flag == 1)
            {
               dmx_start_play(v_pid, a_pid, pcr_pid);
                OS_PRINTF("---------------start filter  \n");
              // dmx_last_tick = dmx_cur_tick;
               start_stop_flag = 0;
            }
        }
    }
}

static  u8   start_stop_flag2 = 0;
static void dmx_errts(u32 v_pid,u32 a_pid, u32 pcr_pid)
{

  static u32 CWValue = 0;
  u32 i;
  dmx_device_t* p_dev    = NULL;
  u32 times = dmx_timeout2 * 3 * 10000;
  u32 dmx_cur_tick =  0;


  p_dev = (dmx_device_t *)dev_find_identifier(NULL
          , DEV_IDT_TYPE, SYS_DEV_TYPE_PTI);
  MT_ASSERT(NULL != p_dev->p_base);




    dmx_start_play(v_pid, a_pid, pcr_pid);
    dmx_desc_set_key(even_key,odd_key);
    while((--times) > 0)
      {
        dmx_cur_tick =  mtos_ticks_get();
        if(dmx_cur_tick > 3000)
        {
        i = dmx_cur_tick / 3000;
        dmx_cur_tick = dmx_cur_tick - (3000 * i );
        }
        OS_PRINTF("ticks  %d \n",dmx_cur_tick);
        if(dmx_cur_tick == 2999)
          {
             CWValue++;
             for(i = 0; i < 4; i++)
              {
                *((volatile u32*)(0x610006c0 + i*4)) = CWValue;
              }
             OS_PRINTF("\n_________PTI Set CW:%x\n", CWValue);
          }
        if(dmx_cur_tick == 2999)
          {
             if(start_stop_flag2 == 0)
              {
                 dmx_stop_play();
                 OS_PRINTF("---------------stop slot/filter   \n");
                 start_stop_flag2 = 1;
              }
             if(start_stop_flag2 == 1)
              {
                  dmx_start_play(v_pid, a_pid, pcr_pid);
                  dmx_desc_set_key(even_key,odd_key);
                  OS_PRINTF("-------------start slot/filter   \n");
                  start_stop_flag2 = 0;
              }
          }
      }

}

static void dmx_filter(u32 pid ,u32 dmx_channel_type)
{

  u32 i = 0;
  u32 times = dmx_timeout2 * 3 * 100;
  RET_CODE ret;
  RET_CODE dmx_ret = ERR_FAILURE;
  dmx_chanid_t  si_channel_id;
  dmx_device_t* p_dev    = NULL;
  dmx_slot_setting_t slot_t;
  dmx_filter_setting_t  filter_param_t;
  u8 *p_buf = NULL;
  u8 *p_buf_align = NULL;
  u8 *p_data = NULL;
  static u32 read_pointer = 0;
  u32 size = 0;
  u32 crc = 0,data;
  BOOL CHECK_RET = TRUE;
  u32 buf_size = dmx_buf_size;
  u32 count = 0, num = 0;

  p_dev = (dmx_device_t *)dev_find_identifier(NULL
          , DEV_IDT_TYPE, SYS_DEV_TYPE_PTI);
  MT_ASSERT(NULL != p_dev->p_base);

  init_filter();
  OS_PRINTF("PID [%d], channel_type[%d]!\n", pid, dmx_channel_type);
  slot_t.in     = 0;
  slot_t.pid   = pid;
  slot_t.type = dmx_channel_type;
  dmx_ret=dmx_si_chan_open(p_dev,&slot_t,&si_channel_id);
  if(dmx_ret!=SUCCESS)
  {
    OS_PRINTF("open si channel failed!\n");
    return;
  }

  p_buf =(u8*)dmx_memory_malloc(buf_size);
  //p_buf =(u8 *) ((u32)&dmx_buffer[0]);
  MT_ASSERT(p_buf != NULL);
  memset(p_buf,0,buf_size);

  p_buf_align = (u8 *)(((u32)p_buf + 7)&0xfffffff8 );
  OS_PRINTF("buf address 0x%08x\n",p_buf_align);
  dmx_ret= dmx_si_chan_set_buffer(p_dev,si_channel_id,p_buf_align,buf_size);
  if(dmx_ret!=SUCCESS)
  {
    OS_PRINTF("set filter buffer failed!\n");
    return;
  }
  filter_param_t.continuous = TRUE;
  filter_param_t.en_crc = TRUE;
  filter_param_t.ts_packet_mode = DMX_EIGHT_MODE;
  memset(filter_param_t.value,0x00,DMX_SECTION_FILTER_SIZE);
  memset(filter_param_t.mask,0x00,DMX_SECTION_FILTER_SIZE);
  //filter_param_t.value[0]=0x02;
  //filter_param_t.mask[0]=0xff;
   if(pid == 0x55)
    {
        filter_param_t.value[0]=TEST_TABLE_ID;
        filter_param_t.mask[0]=0xff;
    }
  if(pid == 0x12)
    {
      for(i = 0; i < 12; i++ )
        {
          filter_param_t.mask[i] = 0;
        }
    }
  if(pid == 0x0)
    {
      for(i = 0; i < 12; i++ )
        {
          filter_param_t.mask[i] = 0;
        }
    }
  dmx_ret=dmx_si_chan_set_filter(p_dev,si_channel_id,&filter_param_t);
  if(dmx_ret!=SUCCESS)
  {
    OS_PRINTF("set filter failed!\n");
    return;
  }
  dmx_ret=dmx_chan_start(p_dev,si_channel_id);
  if(dmx_ret!=SUCCESS)
  {
    OS_PRINTF("start channel  failed!\n");
    return;
  }

  p_data = p_buf_align;
  read_pointer   = 0;
  while(1)
  {
#ifdef  WARRIORS
    ret=dmx_si_chan_get_data(p_dev, si_channel_id, &p_data, &size);
#else
    if(slot_t.type == DMX_CH_TYPE_SECTION)
      ret=dmx_si_chan_get_data(p_dev, si_channel_id, &p_data, &size);
    else
      ret=next_ts_packet_vsb(&p_data, &size,read_pointer,p_buf_align);
#endif
    if(ret != ERR_NO_RSRC )
    {
      if(ret == ERR_STATUS)
        OS_PRINTF("Get crc error data:addr [0x%08x] len[%d]!!!\n",p_data,size);

#ifdef  WARRIORS
         p_data = (u8 *)((u32)p_data |0xa0000000); //convert to non-cacheable address
#else
          p_data = (u8 *)((u32)p_data |0x10000000); //convert to non-cacheable address
#endif

      switch (slot_t.type)
      {
        case DMX_CH_TYPE_SECTION:
          crc = crc_fast_calculate(CRC32_ARITHMETIC_CCITT, 0xFFFFFFFF, p_data, (size-4));
          data = (((u32)p_data[size-4])<<24)|((u32)(p_data[size-3])<<16)|((u32)(p_data[size-2])<<8)|((u32)p_data[size-1]);

          OS_PRINTF("pid 0x%02x Table[%08x] len[%d]:\n",pid,p_data,size);
             for(i=0;i<size;i++)
            OS_PRINTF("%02x ",p_data[i]);
          OS_PRINTF("\n");
          OS_PRINTF("crc [%d]\n", crc);
          OS_PRINTF("data[%d]\n", data);
          if(crc != data)
          {
            CHECK_RET = FALSE;
          }
          break;
        case DMX_CH_TYPE_TSPKT:

          OS_PRINTF("pid 0x%02x Table[%08x] len[%d]:\n",pid,p_data,size);
          for(i=0;i<5;i++)
            OS_PRINTF("%02x ",p_data[i]);
          OS_PRINTF("\n");
          if((size != 188) ||(p_data[0]!=0x47))
          {
            OS_PRINTF("enter1 p_data[%02x], size[%d]\n", p_data[0], size);
            CHECK_RET = FALSE;
          }
          if(((u32)((p_data[1]&0x1F)<<8)|p_data[2]) != slot_t.pid)
          {
            OS_PRINTF("enter pid[%d]\n",(u32)(((p_data[1]&0x1F)<<8)|p_data[2]));
            OS_PRINTF("enter slot_t.pid[%d]\n",slot_t.pid);
            CHECK_RET = FALSE;
          }
          if(num >0)
          {
            if((p_data[3]&0x0F) != (((u32) count+1)%16))
            {
              OS_PRINTF("enter2\n");
                            OS_PRINTF("pdata[%d]\n",(p_data[3]&0xF));
                            OS_PRINTF("count[%d]\n",count);
                            CHECK_RET = FALSE;
            }
          }
            count = (p_data[3]&0xF);
          num ++;
          break;
        case DMX_CH_TYPE_TSPKT_PAYLOAD:
          break;
        case DMX_CH_TYPE_PES:
          break;
      }

      #ifndef  WARRIORS
      if(slot_t.type != DMX_CH_TYPE_SECTION)
      {
        p_data[0] = 0; //pti sync to judge the first byte is equal 0x47
        read_pointer += 188;
        if(read_pointer == dmx_buf_size)
          read_pointer = 0;
      }
      #endif
    }
    if((--times) ==0)
    {
        //OS_PRINTF("time out!!!\n");
        break;
    }

    //OS_PRINTF("[%d].",times);
    mtos_task_delay_ms(1);
  }
  if(CHECK_RET)
  {
    TESTFM_SETRESULT(RET_SUCCESS, 0x2a, FALSE);
  }else{
    TESTFM_SETRESULT(RET_FAIL, 0x10, FALSE);
  }
  ret=dmx_chan_stop(p_dev, si_channel_id);
  MT_ASSERT(ret==SUCCESS);
  ret=dmx_chan_close(p_dev, si_channel_id);
  MT_ASSERT(ret==SUCCESS);
  dmx_memory_free(p_buf);
  OS_PRINTF("filter all used test finished!\n");
  OS_PRINTF("\n");

}

static void dmx_filter_compose(u32 pid,u32 style,  u32 dmx_channel_type)
{

  u32 i = 0;
  u32 times = dmx_timeout2 * 3 * 100;
  RET_CODE ret;
  RET_CODE dmx_ret = ERR_FAILURE;
  dmx_chanid_t  si_channel_id;
  dmx_device_t* p_dev    = NULL;
  dmx_slot_setting_t slot_t;
  dmx_filter_setting_t  filter_param_t;
  u8 *p_buf = NULL;
  u8 *p_buf_align = NULL;
  u8 *p_data = NULL;
  static u32 read_pointer = 0;
  u32 size = 0;
  u32 crc = 0,data;
  BOOL CHECK_RET = TRUE;
  u32 buf_size = dmx_buf_size;
  u32 count = 0, num = 0;

  p_dev = (dmx_device_t *)dev_find_identifier(NULL
          , DEV_IDT_TYPE, SYS_DEV_TYPE_PTI);
  MT_ASSERT(NULL != p_dev->p_base);
  OS_PRINTF("PID [%d], channel_type[%d]!\n", pid, dmx_channel_type);
  slot_t.in     = 0;
  slot_t.pid   = pid;
  slot_t.type = dmx_channel_type;
  dmx_ret=dmx_si_chan_open(p_dev,&slot_t,&si_channel_id);
  if(dmx_ret!=SUCCESS)
  {
    OS_PRINTF("open si channel failed!\n");
    return;
  }

  p_buf =(u8*)dmx_memory_malloc(buf_size);
  //p_buf =(u8 *) ((u32)&dmx_buffer[0]);
  MT_ASSERT(p_buf != NULL);
  memset(p_buf,0,buf_size);

  p_buf_align = (u8 *)(((u32)p_buf + 7)&0xfffffff8 );
  OS_PRINTF("buf address 0x%08x\n",p_buf_align);
  dmx_ret= dmx_si_chan_set_buffer(p_dev,si_channel_id,p_buf_align,buf_size);
  if(dmx_ret!=SUCCESS)
  {
    OS_PRINTF("set filter buffer failed!\n");
    return;
  }
  filter_param_t.continuous = TRUE;
  filter_param_t.en_crc = TRUE;
  filter_param_t.ts_packet_mode = DMX_EIGHT_MODE;
  memset(filter_param_t.value,0x00,DMX_SECTION_FILTER_SIZE);
  memset(filter_param_t.mask,0x00,DMX_SECTION_FILTER_SIZE);
  //filter_param_t.value[0]=0x02;
  //filter_param_t.mask[0]=0xff;
 switch(style)
    {
       case 0:
         for(i =0; i< 12; i++)
          {
            filter_param_t.mask[i] = 0;
          }
            filter_param_t.mask[8] = 8;
            filter_param_t.value[8] = 0xff;
            break;
        case 1:
         for(i =0; i< 12; i++)
          {
            filter_param_t.mask[i] = 0;
          }
            filter_param_t.mask[8] = 8;
            filter_param_t.mask[2] = 2;
            filter_param_t.value[8] = 0xff;
            filter_param_t.value[2] = 0xff;
            break;
        case 2:
         for(i =0; i< 12; i++)
          {
            filter_param_t.mask[i] = 0;
          }
         for(i = 0; i < 12; i++)
          {
            filter_param_t.value[i] = 0xff;
          }
         break;
        default:
        break;
    }
  dmx_ret=dmx_si_chan_set_filter(p_dev,si_channel_id,&filter_param_t);
  if(dmx_ret!=SUCCESS)
  {
    OS_PRINTF("set filter failed!\n");
    return;
  }
  dmx_ret=dmx_chan_start(p_dev,si_channel_id);
  if(dmx_ret!=SUCCESS)
  {
    OS_PRINTF("start channel  failed!\n");
    return;
  }

  p_data = p_buf_align;
  read_pointer   = 0;
  while(1)
  {
#ifdef  WARRIORS
    ret=dmx_si_chan_get_data(p_dev, si_channel_id, &p_data, &size);
#else
    if(slot_t.type == DMX_CH_TYPE_SECTION)
      ret=dmx_si_chan_get_data(p_dev, si_channel_id, &p_data, &size);
    else
      ret=next_ts_packet_vsb(&p_data, &size,read_pointer,p_buf_align);
#endif
    if(ret != ERR_NO_RSRC )
    {
      if(ret == ERR_STATUS)
        OS_PRINTF("Get crc error data:addr [0x%08x] len[%d]!!!\n",p_data,size);

#ifdef  WARRIORS
         p_data = (u8 *)((u32)p_data |0xa0000000); //convert to non-cacheable address
#else
          p_data = (u8 *)((u32)p_data |0x10000000); //convert to non-cacheable address
#endif

      switch (slot_t.type)
      {
        case DMX_CH_TYPE_SECTION:
          crc = crc_fast_calculate(CRC32_ARITHMETIC_CCITT, 0xFFFFFFFF, p_data, (size-4));
          data = (((u32)p_data[size-4])<<24)|((u32)(p_data[size-3])<<16)|((u32)(p_data[size-2])<<8)|((u32)p_data[size-1]);

          OS_PRINTF("pid 0x%02x Table[%08x] len[%d]:\n",pid,p_data,size);
             for(i=0;i<size;i++)
            OS_PRINTF("%02x ",p_data[i]);
          OS_PRINTF("\n");
          OS_PRINTF("crc [%d]\n", crc);
          OS_PRINTF("data[%d]\n", data);
          if(crc != data)
          {
            CHECK_RET = FALSE;
          }
          break;
        case DMX_CH_TYPE_TSPKT:

          OS_PRINTF("pid 0x%02x Table[%08x] len[%d]:\n",pid,p_data,size);
          for(i=0;i<5;i++)
            OS_PRINTF("%02x ",p_data[i]);
          OS_PRINTF("\n");
          if((size != 188) ||(p_data[0]!=0x47))
          {
            OS_PRINTF("enter1 p_data[%02x], size[%d]\n", p_data[0], size);
            CHECK_RET = FALSE;
          }
          if(((u32)((p_data[1]&0x1F)<<8)|p_data[2]) != slot_t.pid)
          {
            OS_PRINTF("enter pid[%d]\n",(u32)(((p_data[1]&0x1F)<<8)|p_data[2]));
            OS_PRINTF("enter slot_t.pid[%d]\n",slot_t.pid);
            CHECK_RET = FALSE;
          }
          if(num >0)
          {
            if((p_data[3]&0x0F) != (((u32) count+1)%16))
            {
              OS_PRINTF("enter2\n");
                            OS_PRINTF("pdata[%d]\n",(p_data[3]&0xF));
                            OS_PRINTF("count[%d]\n",count);
                            CHECK_RET = FALSE;
            }
          }
            count = (p_data[3]&0xF);
          num ++;
          break;
        case DMX_CH_TYPE_TSPKT_PAYLOAD:
          break;
        case DMX_CH_TYPE_PES:
          break;
      }

      #ifndef  WARRIORS
      if(slot_t.type != DMX_CH_TYPE_SECTION)
      {
        p_data[0] = 0; //pti sync to judge the first byte is equal 0x47
        read_pointer += 188;
        if(read_pointer == dmx_buf_size)
          read_pointer = 0;
      }
      #endif
    }
    if((--times) ==0)
    {
        //OS_PRINTF("time out!!!\n");
        break;
    }

    //OS_PRINTF("[%d].",times);
    mtos_task_delay_ms(1);
  }
  if(CHECK_RET)
  {
    TESTFM_SETRESULT(RET_SUCCESS, 0x2a, FALSE);
  }else{
    TESTFM_SETRESULT(RET_FAIL, 0x10, FALSE);
  }
  ret=dmx_chan_stop(p_dev, si_channel_id);
  MT_ASSERT(ret==SUCCESS);
  ret=dmx_chan_close(p_dev, si_channel_id);
  MT_ASSERT(ret==SUCCESS);
  dmx_memory_free(p_buf);
  OS_PRINTF("filter compose test finished!\n");
  OS_PRINTF("\n");;
}

#define CPU2TS_CH0_REG     (*(volatile unsigned int *)0x6f8b0000)
#define CPU2TS_CH1_REG     (*(volatile unsigned int *)0x6f8b0020)
static void dmx_avplay(u32 mode, u32 dec_mode)
{
    u32 *pdata;
    u32 len = 0;
    u32 i;
    u32 regval;

    hal_put_u32((u32 *)0x6f8a0004, 0x11);
    //reset
    regval = hal_get_u32((u32 *)0x6f80000c);
    regval &= 0xffffffbf;
    hal_put_u32((u32 *)0x6f80000c, regval);
    regval = hal_get_u32((u32 *)0x6f800010);
    regval &= 0xffffffbf;
    hal_put_u32((u32 *)0x6f800010, regval);
    hal_put_u32((u32 *)0x6f80000c, 0xffffffff);
    hal_put_u32((u32 *)0x6f800010, 0xffffffff);

    //close avsync
    hal_put_u32((u32 *)0x6f830024, 0);
    hal_put_u32((u32 *)0x6f830028, 0);

    if(mode == 0)
      {
        OS_PRINTF("\n-----------test play audio pes-----------\n");
        if(dec_mode)
          {
             hal_put_u32((u32 *)0x6f8a0004, 0xb11);
             regval = hal_get_u32((u32 *)0x6f8a0000);
             regval &= (~0x00000008);
             hal_put_u32((u32 *)0x6f8a0000, regval);
          }
        else
          {
             hal_put_u32((u32 *)0x6f8a0004, 0x311);
             regval = hal_get_u32((u32 *)0x6f8a0000);
             regval |= 0x00000008;
             hal_put_u32((u32 *)0x6f8a0000, regval);
          }
        //reset
        regval = hal_get_u32((u32 *)0x6f800004);
        regval |= 0x1;
        hal_put_u32((u32 *)0x6f800004, regval);

        //pdata = apes;
        //len = sizeof(apes)/4;

        for(i = 0; i < len; i++)
          {
            while((hal_get_u32((u32 *)0x6f900004)>>16) > 100);
            CPU2TS_CH1_REG =  *pdata;
            pdata++;
          }
      }
    else if (mode == 1)
      {
         OS_PRINTF("\n--------test play audio ts-----------\n");
         hal_put_u32((u32 *)0x6f8a0008, 0x58 << 16);

         //reset
          regval = hal_get_u32((u32 *)0x6f800004);
          regval |= 0x1;
          hal_put_u32((u32 *)0x6f800004, regval);

          //pdata = ts;
          //len = sizeof(ts)/4;

          for(i = 0; i < len; i++)
            {
              while((hal_get_u32((u32 *)0x6f900004)>>16) > 100);
              CPU2TS_CH0_REG =  *pdata;
              pdata++;
            }
      }
    else if(mode == 2)
      {
         OS_PRINTF("\n--------test play video pes-----------\n");

          regval = hal_get_u32((u32 *)0x6f800004);
          regval |= 0x1;
          hal_put_u32((u32 *)0x6f800004, regval);

          //init video
          regval = hal_get_u32((u32 *)0x50000000);
          regval |= 0x1;
          hal_put_u32((u32 *)0x50000000, regval);

          if(dec_mode)
            {
             hal_put_u32((u32 *)0x6f8a0004, 0x611);
             regval = hal_get_u32((u32 *)0x6f8a0000);
             regval &= (~0x00000008);
             hal_put_u32((u32 *)0x6f8a0000, regval);
            }
          else
            {
             hal_put_u32((u32 *)0x6f8a0004, 0x211);
             regval = hal_get_u32((u32 *)0x6f8a0000);
             regval |= 0x00000008;
             hal_put_u32((u32 *)0x6f8a0000, regval);
            }

          //pdata = vpes;
          //len = sizeof(vpes)/4;
          for(i = 0; i < len; i++)
            {
              while((hal_get_u32((u32 *)0x6f900004)&0xffff) > 170);
              CPU2TS_CH0_REG =  *pdata;
              pdata++;
            }
      }
    else if(mode == 3)
      {
         OS_PRINTF("\n-----------test play video ts------------\n");

          //init video
          regval = hal_get_u32((u32 *)0x50000000);
          regval |= 0x1;
          hal_put_u32((u32 *)0x50000000, regval);

          //reset
          regval = hal_get_u32((u32 *)0x6f800004);
          regval |= 0x1;
          hal_put_u32((u32 *)0x6f800004, regval);

          hal_put_u32((u32 *)0x6f8a0008, 0xa2);
          //pdata = ts;
          //len = sizeof(ts)/4;

          for(i = 0; i < len; i++)
            {
              while((hal_get_u32((u32 *)0x6f900004)&0xffff) > 170);
              CPU2TS_CH0_REG =  *pdata;
              pdata++;
            }
      }
}
#endif

static void dmx_receive(u32 pid, u32 dmx_channel_type,u32 mode)
{
  u8 temp_buf[4096];
  u32 i = 0;
  u32 times = dmx_timeout2 * 3 * 100;
  RET_CODE ret;
  RET_CODE dmx_ret = ERR_FAILURE;
  dmx_chanid_t  si_channel_id;
  dmx_device_t* p_dev    = NULL;
  dmx_slot_setting_t slot_t;
  dmx_filter_setting_t  filter_param_t;
  u8 *p_buf = NULL;
  u8 *p_buf_align = NULL;
  u8 *p_data = NULL;
  static u32 read_pointer = 0;
  u32 size = 0;
  u32 crc = 0,data;
  BOOL CHECK_RET = TRUE;
  BOOL CHECK_GET_DATA = FALSE;
  u32 buf_size = dmx_buf_size;
  u32 count = 0, num = 0;
  u32 read_ts = 0;
  u32 packet_num = 0;

  p_dev = (dmx_device_t *)dev_find_identifier(NULL
          , DEV_IDT_TYPE, SYS_DEV_TYPE_PTI);
  MT_ASSERT(NULL != p_dev->p_base);
  OS_PRINTF("PID [%d], channel_type[%d]!\n", pid, dmx_channel_type);
  slot_t.in     = 0;
  slot_t.pid   = pid;
  slot_t.type = dmx_channel_type;
  dmx_ret=dmx_si_chan_open(p_dev,&slot_t,&si_channel_id);
  if(dmx_ret!=SUCCESS)
  {
    OS_PRINTF("open si channel failed!\n");
    return;
  }

  p_buf =(u8*)dmx_memory_malloc(buf_size);
  //p_buf =(u8 *) ((u32)&dmx_buffer[0]);
  MT_ASSERT(p_buf != NULL);
  memset(p_buf,0,buf_size);

  p_buf_align = (u8 *)(((u32)p_buf + 7)&0xfffffff8 );
  OS_PRINTF("buf address 0x%08x\n",p_buf_align);
  dmx_ret= dmx_si_chan_set_buffer(p_dev,si_channel_id,p_buf_align,buf_size);
  if(dmx_ret!=SUCCESS)
  {
    OS_PRINTF("set filter buffer failed!\n");
    return;
  }
  filter_param_t.continuous = mode;
  filter_param_t.en_crc = TRUE;
  
#ifdef JAZZ
  if(slot_t.type == DMX_CH_TYPE_TSPKT)
  {
      filter_param_t.continuous = 1;
      filter_param_t.req_mode = DMX_REQ_MODE_CONTINUOUS_TS;
      filter_param_t.en_crc = FALSE;
  }
  else
  {
      filter_param_t.req_mode = DMX_REQ_MODE_FILTER_LOOPBUFF;
  }
#endif
  
#ifndef JAZZ
    #ifndef  WARRIORS
        filter_param_t.ts_packet_mode = DMX_EIGHT_MODE;
    #else
        filter_param_t.ts_packet_mode = DMX_ONE_MODE;
    #endif
#endif

  memset(filter_param_t.value,0x00,DMX_SECTION_FILTER_SIZE);
  memset(filter_param_t.mask,0x00,DMX_SECTION_FILTER_SIZE);

#ifdef JAZZ
switch(pid)
{
  case 0x12://EIT
      filter_param_t.value[0] = 0x4e;
      filter_param_t.mask[0] = 0xff;
    break;

  case 0x11://SDT
      filter_param_t.value[0] = 0x42;
      filter_param_t.mask[0] = 0xff;
    break;

  case 0x10://NIT
      filter_param_t.value[0] = 0x40;
      filter_param_t.mask[0] = 0xff;
    break;

  case 0x00://PAT
      filter_param_t.value[0] = 0x00;
      filter_param_t.mask[0] = 0xff;
    break;

  case 0x01://CAT
      filter_param_t.value[0] = 0x01;
      filter_param_t.mask[0] = 0xff;
    break;
}


    OS_PRINTF("set table id=0x%02x\n",filter_param_t.value[0]);

#endif

  dmx_ret=dmx_si_chan_set_filter(p_dev,si_channel_id,&filter_param_t);
  if(dmx_ret!=SUCCESS)
  {
    OS_PRINTF("set filter failed!\n");
    return;
  }
  dmx_ret=dmx_chan_start(p_dev,si_channel_id);
  if(dmx_ret!=SUCCESS)
  {
    OS_PRINTF("start channel  failed!\n");
    return;
  }

  p_data = p_buf_align;
  read_pointer   = 0;
  while(1)
  {
#ifdef  WARRIORS
    ret = dmx_si_chan_get_data(p_dev, si_channel_id, &p_data, &size);
#else
    if(slot_t.type == DMX_CH_TYPE_SECTION)
      ret=dmx_si_chan_get_data(p_dev, si_channel_id, &p_data, &size);
    else
      ret=next_ts_packet_vsb(&p_data, &size,read_pointer,p_buf_align);
#endif
    if(ret != ERR_NO_RSRC )
    {
      CHECK_GET_DATA = TRUE;
      if(ret == ERR_STATUS)
        OS_PRINTF("Get crc error data:addr [0x%08x] len[%d]!!!\n",p_data,size);

#ifdef  WARRIORS
        #ifndef __LINUX__
         p_data = (u8 *)((u32)p_data |0xa0000000); //convert to non-cacheable address
         #endif
#else
#ifndef JAZZ
          p_data = (u8 *)((u32)p_data |0x10000000); //convert to non-cacheable address
#endif
#endif

      switch (slot_t.type)
      {
        case DMX_CH_TYPE_SECTION:
          memcpy(temp_buf,p_data,size);

          crc = crc_fast_calculate(CRC32_ARITHMETIC_CCITT, 0xFFFFFFFF, p_data, (size-4));
          data = (((u32)p_data[size-4])<<24)|((u32)(p_data[size-3])<<16)|((u32)(p_data[size-2])<<8)|((u32)p_data[size-1]);

          OS_PRINTF("pid 0x%02x Table[%08x] len[%d]:\n",pid,p_data,size);
             for(i=0;i<5;i++)
            OS_PRINTF("%02x ",temp_buf[i]);
          OS_PRINTF("\n");
          OS_PRINTF("crc [%d]\n", crc);
          OS_PRINTF("data[%d]\n", data);
          if(crc != data)
          {
            CHECK_RET = FALSE;
          }
          packet_num++;
          break;
        case DMX_CH_TYPE_TSPKT:

          OS_PRINTF("pid 0x%02x Table[%08x] len[%d]:\n",pid,p_data,size);
          MT_ASSERT(size%188 == 0);
          read_ts = size;
          while(read_ts)
          {
          for(i=0;i<5;i++)
            OS_PRINTF("%02x ",p_data[i]);
          OS_PRINTF("\n");
              if((size%188 != 0) ||(p_data[0]!=0x47))
          {
            OS_PRINTF("enter1 p_data[%02x], size[%d]\n", p_data[0], size);
            CHECK_RET = FALSE;
          }
          if(((u32)((p_data[1]&0x1F)<<8)|p_data[2]) != slot_t.pid)
          {
            OS_PRINTF("enter pid[%d]\n",(u32)(((p_data[1]&0x1F)<<8)|p_data[2]));
            OS_PRINTF("enter slot_t.pid[%d]\n",slot_t.pid);
            CHECK_RET = FALSE;
          }
          if(num >0)
          {
            if((p_data[3]&0x0F) != (((u32) count+1)%16))
            {
              OS_PRINTF("enter2\n");
                            OS_PRINTF("pdata[%d]\n",(p_data[3]&0xF));
                            OS_PRINTF("count[%d]\n",count);
                            CHECK_RET = FALSE;
            }
          }
            count = (p_data[3]&0xF);
          num ++;
              read_ts -= 188;
              #ifndef JAZZ
              p_data += 188;
              #endif
          }
          break;
        case DMX_CH_TYPE_TSPKT_PAYLOAD:
          break;
        case DMX_CH_TYPE_PES:
          break;
      }

      #ifndef  WARRIORS
      if(slot_t.type != DMX_CH_TYPE_SECTION)
      {
        p_data[0] = 0; //pti sync to judge the first byte is equal 0x47
        #ifndef JAZZ
        read_pointer += 188;
        #else
        read_pointer += 192; // 4bytes is added by software while copy data. slot_id(1)+filter_id(1)+data_len(2)+188bytes
        #endif
        if(read_pointer == dmx_buf_size)
          read_pointer = 0;
      }
      #endif
    }
    if((--times) ==0)
    {
        //OS_PRINTF("time out!!!\n");
        break;
    }

    //OS_PRINTF("[%d].",times);
    mtos_task_delay_ms(1);
	#ifdef __LINUX__
    usleep(1000);
	#endif
  
  if(mode == 0 && packet_num == 1)
    break;
  }

  if(CHECK_RET & CHECK_GET_DATA)
  {
     if(slot_t.type == DMX_CH_TYPE_SECTION)
     {
          switch(mode)
          {
             case 1:
              if(packet_num >= 1)   //section continus mode
              {
                 OS_PRINTF("all section num is %d!\n",packet_num);
                 TESTFM_SETRESULT(RET_SUCCESS, 0x2a, FALSE);
              }
              else
                  TESTFM_SETRESULT(RET_FAIL, 0x2a, FALSE);
              break;
             case 0:
              if(packet_num == 1)   //section single mode
              {
                 OS_PRINTF("get only one section!\n");
                 TESTFM_SETRESULT(RET_SUCCESS, 0x2a, FALSE);
              }
              else
                  TESTFM_SETRESULT(RET_FAIL, 0x2a, FALSE);
              break;
             default:
              break;
          }
    }
    else    //ts pakcet
    {
        TESTFM_SETRESULT(RET_SUCCESS, 0x2a, FALSE);
    }
 }
 else
  TESTFM_SETRESULT(RET_FAIL, 0x10, FALSE);
 
  ret=dmx_chan_stop(p_dev, si_channel_id);
  MT_ASSERT(ret==SUCCESS);
  ret=dmx_chan_close(p_dev, si_channel_id);
  MT_ASSERT(ret==SUCCESS);
  dmx_memory_free(p_buf);
  OS_PRINTF("channel test finished!\n");
  OS_PRINTF("\n");
}

#ifdef JAZZ
extern void DRV_PTI_ShowInfo ( u32 flag);
#endif

static void param_parse(char param, u32 *p_data, u32 length)
{
  switch (param)
  {
    case 'd':
      dmx_si_channel_set(p_data[0], p_data[1],p_data[2],p_data[3],p_data[4],p_data[5]);
      break;
    case 't':
      dmx_eit_test_cmd(p_data[0]);
      break;

#ifdef WARRIORS
    case 'i':
      dmx_stream_input_select(p_data[0]);
      break;
    case 'r':
      dmx_rec_channel_set(p_data,length);
      break;
    case 'n':
      dmx_rec_network_test(p_data[0], p_data[1],p_data[2],p_data[3],p_data[4]);
      break;
    case 'c':
      dmx_play_rec_content_test(p_data[0], p_data[1],p_data[2],p_data[3],p_data[4]);
      break;
    case 'a':
      dmx_dma_one_frame(ts_logo_data, (u16)get_ts_logo_size(),168 * 4,0x1011);
      break;
    case 'v':
      parse_av_ts_stream();
      break;
    case 'f':
        dmx_ufs_test(p_data,length);
      break;
    case 'l':
	   #ifdef __LINUX__
        dmx_file_test(p_data[0], p_data[1],p_data[2],p_data[3]);
	   #else
	    dmx_ddr_file_test(p_data[0], p_data[1],p_data[2],p_data[3]);
	   #endif
      break;
#endif

#ifdef ORCHID
#if 1
    case 'c':
      dmx_rec_test();
      break;
    case 'f':
      dmx_file_test();
      break;
#endif
    case 'u':
      dmx_pes_test(p_data[0],p_data[1], p_data[2]);
      break;
#endif
    case 'p':
      dmx_tp_parse();     // ok
      break;
    case 's':
      dmx_start_play(p_data[0], p_data[1],p_data[2]);
      break;
    case 'q':
      dmx_stop_play();
      break;
    case 'k':
      dmx_desc_test_cmd(p_data[0]);
      break;
    case 'z':
      dmx_receive(p_data[0], p_data[1],p_data[2]);
      break;
#ifdef JAZZ
     case'o':
      dmx_protect(p_data[0], p_data[1], p_data[2]); //for jazz  filter/slot protect
      break;
     case'e':
      dmx_errts(p_data[0], p_data[1], p_data[2]);  //for jazz  error ts
      break;
     case'l':
      dmx_filter(p_data[0], p_data[1]);  //for jazz  filter all used
      break;
     case'm':
      dmx_filter_compose(p_data[0], p_data[1], p_data[2]);//for jazz
      break;
     case'j':
      dmx_avplay(p_data[0], p_data[1]);// for jazz pes play
      break;
    case 'y':
      DRV_PTI_ShowInfo(0);
      break;
#endif
    default:
      TESTFM_LOG("Wrong command parameter!\n");
      TESTFM_SETRESULT(RET_FAIL, 0x10, FALSE);
      return;
  }
}

static void cmd_dmx(void)
{
  char tmp[32];
  char param = 0;
  u32 data[131] = {0};
  u32 i = 0;
  while (1)
  {
    memset(tmp, 0x0, 32);
    testfm_console_get_parameter(tmp, ' ');
    if (tmp[0] == '-')
    {
      param = tmp[1];
      OS_PRINTF("param  = %c\n", param);
    }
    else if (tmp[0] != 0x0)
    {
          data[i++] = testfm_get_num(tmp);
//      OS_PRINTF("%d, %d, %d, %d, %d, %d\n", tmp[0], tmp[1], tmp[2], tmp[3], tmp[4], data[i-1]);
//      OS_PRINTF("param[%d] = %c\n", i-1, param[i-1]);
    }
    else
    {
      break;
    }
  }
  param_parse(param, data, i);

}

static u32 dmx_begin_to_rece_emm(dmx_chanid_t  *emm_channel_id, u32 size)
{
  RET_CODE dmx_ret = ERR_FAILURE;
  dmx_chanid_t  si_channel_id;
  dmx_device_t* p_dev    = NULL;
  dmx_slot_setting_t slot_t;
  dmx_filter_setting_t  filter_param_t;
  u8 *p_buf = NULL;

  p_dev = (dmx_device_t *)dev_find_identifier(NULL
          , DEV_IDT_TYPE, SYS_DEV_TYPE_PTI);
  MT_ASSERT(NULL != p_dev->p_base);

  slot_t.in     = 0;
  slot_t.pid   = 0x1010;
  slot_t.type = DMX_CH_TYPE_TSPKT;
  dmx_ret=dmx_si_chan_open(p_dev,&slot_t,&si_channel_id);
  if(dmx_ret!=SUCCESS)
  {
    OS_PRINTF("open si channel failed!\n");
    return 0;
  }

  p_buf =(u8 *)dmx_memory_malloc(size);
  MT_ASSERT(p_buf != NULL);

  OS_PRINTF("buf address 0x%08x\n",p_buf);
  dmx_ret= dmx_si_chan_set_buffer(p_dev,si_channel_id,p_buf,size);
  if(dmx_ret!=SUCCESS)
  {
    OS_PRINTF("set filter buffer failed!\n");
    return 0;
  }

  filter_param_t.continuous = TRUE;
  filter_param_t.ts_packet_mode = DMX_ONE_MODE;

  dmx_ret=dmx_si_chan_set_filter(p_dev,si_channel_id,&filter_param_t);
  if(dmx_ret!=SUCCESS)
  {
    OS_PRINTF("set filter failed!\n");
    return 0;
  }

  dmx_ret=dmx_chan_start(p_dev,si_channel_id);
  if(dmx_ret!=SUCCESS)
  {
    OS_PRINTF("start channel  failed!\n");
    return 0;
  }
  *emm_channel_id = si_channel_id;
  return (u32)p_buf;
}

static void dmx_stop_to_rece_emm(dmx_chanid_t  emm_channel_id, u8 *p_buf)
{
    RET_CODE dmx_ret = ERR_FAILURE;
    dmx_device_t* p_dev    = NULL;

    p_dev = (dmx_device_t *)dev_find_identifier(NULL
            , DEV_IDT_TYPE, SYS_DEV_TYPE_PTI);
    MT_ASSERT(NULL != p_dev->p_base);
    
    dmx_ret = dmx_chan_stop(p_dev, emm_channel_id);
    MT_ASSERT(dmx_ret == SUCCESS);

    dmx_ret = dmx_chan_close(p_dev, emm_channel_id);
    MT_ASSERT(dmx_ret == SUCCESS);

    dmx_memory_free(p_buf);

}

static BOOL dmx_check_ecm_key(u8 *p_pkt,u8 *even_key, u8 *odd_key)
{
    //u8 i = 0;
    BOOL flag = FALSE;
    if(memcmp((p_pkt + 0x10),even_key,8) != 0)
    {
        flag = TRUE;
        memcpy(even_key,(p_pkt + 0x10),8);
    }

    if(memcmp((p_pkt + 0x20),odd_key,8) != 0)
    {
        flag = TRUE;
        memcpy(odd_key,(p_pkt + 0x20),8);
    }

    return flag;
}

static void dmx_proc(void *p_data)
{
    BOOL        rc = FALSE;
    os_msg_t    msg;
    dmx_cmd_evt_t dmx_evt = DMX_CMD_NONE;
    u32 p_buf = 0;
    u32 p_pkt = 0;
    u32 ecm_buf_size = 128 * 188;
    dmx_chanid_t  emm_channel_id = 0;
    
    while(1)
    {
        rc = mtos_messageq_receive(dmx_cmd_msg_handle, &msg, 100);

        if(rc == TRUE)
        {
            switch(msg.content)
            {
                case DMX_DESC_TEST_START:
                    dmx_evt = DMX_DESC_TEST_START;
                    OS_PRINTF("[dmx cmd]begin to test descramble!!!\n");
                    p_buf = dmx_begin_to_rece_emm(&emm_channel_id,ecm_buf_size);
                    p_pkt = p_buf;
                    break;
                case DMX_DESC_TEST_STOP:
                    dmx_evt = DMX_DESC_TEST_STOP;
                    OS_PRINTF("[dmx cmd]stop to test descramble!!!\n");
                    dmx_desc_close();
                    dmx_stop_to_rece_emm(emm_channel_id,(u8 *)p_buf);
                    break;
                case DMX_EIT_TEST_START:
                    dmx_evt = DMX_EIT_TEST_START;
                    OS_PRINTF("[dmx cmd]begin to test eit!!!\n");
                    dmx_eit_test_start();
                    break;
                 case DMX_EIT_TEST_STOP:
                    OS_PRINTF("[dmx cmd]stop to test eit!!!\n");
                    dmx_eit_test_stop();
                    break;  
                default:
                    break;
            }
        }
        else
        {
            switch(dmx_evt)
            {
                case DMX_DESC_TEST_START:
                    if(((u8 *)p_pkt)[0] == 0x47)
                    {
                        if(dmx_check_ecm_key((u8 *)p_pkt,even_key,odd_key) == TRUE)
                        {
                            u8 i = 0;
                            OS_PRINTF("set even key: ");
                            for(i = 0; i < 8; i++)
                                OS_PRINTF("%02x ",even_key[i]);

                            OS_PRINTF("\nset odd key: ");
                            for(i = 0; i < 8; i++)
                                OS_PRINTF("%02x ",odd_key[i]);

                            OS_PRINTF("\n");

                            dmx_desc_set_key(even_key,odd_key);
                        }

                       ((u8 *)p_pkt)[0] = 0x0; 
                       if(p_pkt == (p_buf + (ecm_buf_size - 188)))
                            p_pkt = p_buf;
                       else
                            p_pkt += 188;
                    }
                    break;
                case DMX_EIT_TEST_START:
                    dmx_eit_rece_data();
                    break;
                default:
                    break;
            }
        }
    }
}

static s32 cmd_dmx_init(void)
{
  void *p_pti = NULL;
  RET_CODE ret;
  u32 *p_stack = NULL;
  
  p_pti = dev_find_identifier(NULL, DEV_IDT_TYPE, SYS_DEV_TYPE_PTI);
  MT_ASSERT(NULL != p_pti);

  if(dmx_open_flag == FALSE)
  {
    ret = dev_open(p_pti, NULL);
    MT_ASSERT(SUCCESS == ret);
    dmx_open_flag = TRUE;
#if (defined ORCHID || defined WARRIORS)
    {
        OS_PRINTK("vfs mount begin\n");
    	#ifndef __LINUX__
        vfs_t *p_vfs = class_get_handle_by_id(VFS_CLASS_ID);
        p_vfs->mount(0);
       #endif
        OS_PRINTK("vfs mount ok!\n");
    }
#endif


    //create one task for demux process
    p_stack = (u32*)mtos_malloc(DMX_TASK_STK_SIZE);
    MT_ASSERT(p_stack != NULL);
    
    dmx_cmd_msg_handle  = mtos_messageq_create(DMX_MSG_DEPTH, (u8 *)"DMX");
    ret = mtos_task_create((u8 *)"dmxdrvtest",
                                    dmx_proc, 
                                    (void *)0, 
                                    DMX_DRVCMD_TASK_PRIORITY,
                                    p_stack, 
                                    DMX_TASK_STK_SIZE);
    MT_ASSERT(FALSE != ret);
  }
  
#ifdef __LINUX__
  dmx_get_record_buffer(p_pti, &dmx_rec_buffer_address);
  if(!dmx_rec_buffer_address)
    printf("dmx_get_record_buffer fail\n");
  printf("dmx_rec_buffer_address = 0x%p\n", dmx_rec_buffer_address);
#endif

  return 0;
}

static s32 cmd_dmx_deinit(void)
{
#if 0
  void *p_pti = NULL;
  RET_CODE ret;

  p_pti = dev_find_identifier(NULL, DEV_IDT_TYPE, SYS_DEV_TYPE_PTI);
  MT_ASSERT(NULL != p_pti);
  ret = dev_close(p_pti);
  MT_ASSERT(SUCCESS == ret);
#endif
  return 0;
}

void dmx_init_cmd(void)
{
  testfm_p_suite_t p_suite = NULL;

  p_suite = testfm_add_suite("dmx", cmd_dmx_init, cmd_dmx_deinit);
  testfm_add_cmd(p_suite, "dmx", cmd_dmx, cmd_dmx_help,
                               PLATFORM_MAGIC |PLATFORM_WARRIORS|PLATFORM_JAZZ, FALSE);
}


